import "system.jc"
import "gui2d.jc"
import "s-d-l.jc"
import "javascript.jc"
import "pipe-waiter.jc"
import System.Algorithm.*
import System.Math.*
import System.Console.*
import Javascript.*

/*
Qiming HOU 1/1/2017:
	adapting the whole thing to jc
	abandoned the mouse stuff in favor of quickedit-like operations
*/
module detail{
/**
* xterm.js: xterm, in the browser
* Originally forked from (with the author's permission):
*   Fabrice Bellard's javascript vt100 for jslinux:
*   http://bellard.org/jslinux/
*   Copyright (c) 2011 Fabrice Bellard
*   The original design remains. The terminal itself
*   has been extended to include xterm CSI codes, among
*   other features.
* @license MIT
*/

/**
* Terminal Emulation References:
*   http://vt100.net/
*   http://invisible-island.net/xterm/ctlseqs/ctlseqs.txt
*   http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
*   http://invisible-island.net/vttest/
*   http://www.inwap.com/pdp10/ansicode.txt
*   http://linux.die.net/man/4/console_codes
*   http://linux.die.net/man/7/urxvt
*/

/**
* States
*/
auto normal_state=0, escaped=1, csi=2, osc=3, charset_state=4, dcs=5, ignore=6;
auto VISUAL_BELL_DURATION=0.5

/**
* Terminal
*/

false=0
true=1
MAX_PARSABLE_LINE=1024
class Terminal{
	//self.cancel=Terminal.cancel;
	colors= g_colors
	theme= 'default'
	convertEol= true
	termName= 'xterm'
	//termName= 'linux'
	geometry= [80, 25]
	cursorBlink= false
	//visualBell= false
	popOnBell= false
	scrollback= 1000
	screenKeys= false
	debug= false
	cancelEvents= false
	/**
	* The scroll position of the y cursor, ie. ybase + y=the y position within the entire
	* buffer
	*/
	ybase=0

	/**
	* The scroll position of the viewport
	*/
	ydisp=0

	/**
	* The cursor's x position after ybase
	*/
	x=0

	/**
	* The cursor's y position after ybase
	*/
	y=0

	/**
	* Used to debounce the refresh function
	*/
	isRefreshing=false

	/**
	* Whether there is a full terminal refresh queued
	*/

	cursorState=0
	cursorHidden=false
	state=0
	//queue=new string
	scrollTop=0
	scrollBottom=0
	//customKeydownHandler=null

	// modes
	applicationKeypad=false
	applicationCursor=false
	originMode=false
	insertMode=false
	wraparoundMode=true // defaults: xterm - true, vt100 - false
	has_normal=0
	//normal=null

	// charset
	charset=int[int].NULL
	glevel=0
	charsets=new int[int][int]

	// mouse properties
	//decLocator
	//x10Mouse
	//vt200Mouse
	//vt300Mouse
	//normalMouse
	//mouseEvents
	//sendFocus
	//utfMouse
	//sgrMouse
	//urxvtMouse

	// misc
	savedX=0
	savedY=0
	savedCols=0

	// stream
	readable=true
	writable=true

	defAttr=(0 << 18) | (257 << 9) | (256 << 0)
	curAttr=(0 << 18) | (257 << 9) | (256 << 0)

	params=new int[]
	currentParam=0
	currentStringParam=new string
	prefix=new string
	//postfix=0

	// leftover surrogate high from previous write invocation
	s_lingering=string.NULL

	tabs=string.NULL
	title=string.NULL
	
	cols=0
	rows=0
	lines=int[].NULL
	line_end_states=int[].NULL //default: \n, 1: wrapped
	n_valid_lines=0
	need_update=0
	gcharset=0
	input_during_download=string.NULL
	input_pipe_queue=string.NULL
	normal=__uninit()
	sendFocus=false
	bell_tick=System.Time.tick64()
	m_IME_overlay=string.NULL
	has_focus=false

	// Store if user went browsing history in scrollback
	userScrolling=false
	download_buf=string.NULL
	download_written_size=0LL
	download_size=-1LL
	download_start=0LL
	download_file=System.IO.CFile.NULL
	/**
	* Creates a new `Terminal` object.
	*
	* @param {object} options An object containing a set of options, the available options are:
	*   - `cursorBlink` (boolean): Whether the terminal cursor blinks
	*   - `cols` (number): The number of columns of the terminal (horizontal size)
	*   - `rows` (number): The number of rows of the terminal (vertical size)
	*
	* @public
	* @class Xterm Xterm
	* @alias module:xterm/src/xterm
	*/
	inline __init__(param_cols,param_rows){
		scrollBottom=param_rows - 1
		this.cols=param_cols
		this.rows=param_rows
		this.geometry[0]=param_cols
		this.geometry[1]=param_rows
		/**
		* An array of all lines in the entire buffer, including the prompt. The lines are array of
		* characters which are 3-length arrays where [0] is an attribute and [1] is the character.
		* and [2] is the character width
		*/
		//Writeln('this.scrollback*this.cols*3=',this.scrollback*this.cols*3,' ',this.scrollback,' ',this.cols,' ',param_cols)
		this.lines=new int[]
		this.line_end_states=new int[]
		this.n_valid_lines=0
		this.ybase=0
		this.ydisp=0
		this.setupStops(0);
	}
	/**
	* back_color_erase feature for xterm.
	*/
	eraseAttr=inline() {
		// if (this.is('screen')) return this.defAttr;
		return (this.defAttr & ~0x1ff) | (this.curAttr & 0x1ff);
	};
	destroy=function() {
		this.readable=false;
		this.writable=false;
		this.lines=int[].NULL;
		if this.proc:
			//if this.proc.pipe:
			//	PipeWaiter.RemovePipe(proc.pipe)
			//if this.proc.pipe_2nd:
			//	PipeWaiter.RemovePipe(proc.pipe_2nd)
			this.proc=System.Processes.CProcess.NULL
		//this._events={};
		//this.handler=function() {};
	};
	moveRows=function(tar,src,n)
		if !(n>0):return
		szrow=this.cols*(3*sizeof(int))
		if tar<src:
			this.requestLines(src+n)
			for i=0:n-1
				this.line_end_states[(tar+i)%this.scrollback]=this.line_end_states[(src+i)%this.scrollback]
				__basic_api.memcpy(
					__pointer(this.lines.d+(tar+i)%this.scrollback*szrow),__pointer(this.lines.d+(src+i)%this.scrollback*szrow),szrow)
		else
			this.requestLines(tar+n)
			for i=n-1:-1:0
				tar_i=(tar+i)%this.scrollback
				this.line_end_states[tar_i]=this.line_end_states[(src+i)%this.scrollback]
				__basic_api.memcpy(
					__pointer(this.lines.d+tar_i*szrow),__pointer(this.lines.d+(src+i)%this.scrollback*szrow),szrow)
	
	requestLines=function(int nlines){
		if nlines>this.n_valid_lines:
			this.n_valid_lines=min(nlines,this.scrollback)
			this.lines.resize(this.n_valid_lines*this.cols*3)
			this.line_end_states.resize(this.n_valid_lines)
	}
	
	clearWithAttr=function(pchar,attr,nchar){
		if !(nchar>0):return
		requestLines((pchar+nchar+this.cols-1)/this.cols)
		//clear line_end_states
		for row=pchar/this.cols:(pchar+nchar+this.cols-1)/this.cols-1
			row_real=row%this.scrollback
			if row_real<this.line_end_states.n:
				this.line_end_states[row_real]=0
		if pchar+nchar>this.lines.n:
			for i=pchar:this.lines.n-1
				this.lines[(i)*3+0]=attr
				this.lines[(i)*3+1]=32
				this.lines[(i)*3+2]=0
			for i=this.lines.n:pchar+nchar-1
				this.lines[(i-this.lines.n)*3+0]=attr
				this.lines[(i-this.lines.n)*3+1]=32
				this.lines[(i-this.lines.n)*3+2]=0
		else
			for i=0:nchar-1
				this.lines[(pchar+i)*3+0]=attr
				this.lines[(pchar+i)*3+1]=32
				this.lines[(pchar+i)*3+2]=0
	}
	
	/**
	* Scroll the terminal down 1 row, creating a blank line.
	*/
	scroll=function() {
		auto row;
		if this.scrollTop > 0:
			//we're not moving the base, nor are we adding any lines
			n_lines_kept=this.scrollBottom-this.scrollTop
			this.moveRows(this.scrollTop,this.scrollTop+1,n_lines_kept)
			row=(this.ybase + this.scrollBottom)%this.scrollback;
			// blank out the scrollsed line
			this.clearWithAttr(row*this.cols,this.defAttr,this.cols)
		else
			this.ybase++;
			if this.ybase>=this.scrollback:
				this.ybase=0
	
			if (!this.userScrolling) {
				this.ydisp=this.ybase;
			}
	
			// last line
			row=this.ybase + this.rows - 1;
			row%=this.scrollback
			row_bottom=row
			
			// subtract the bottom scroll region
			n_lines_kept_bottom=this.rows - 1 - this.scrollBottom
			row -= n_lines_kept_bottom;
			row+=this.scrollback
			row%=this.scrollback
	
			if (row == row_bottom) {
				//do nothing
			} else {
				// add our new line... at row
				this.moveRows(row+1,row,n_lines_kept_bottom);
			}
			// blank out the recycled line after going over it
			this.clearWithAttr(row*this.cols,this.defAttr,this.cols)
	
		/**
		* This event is emitted whenever the terminal is scrolled.
		* The one parameter passed is the new y display position.
		*
		* @event scroll
		*/
		//this.emit('scroll', this.ydisp);
	};
	
	/**
	* Scroll the display of the terminal
	* @param {number} disp The number of lines to scroll down (negatives scroll up).
	* @param {boolean} suppressScrollEvent Don't emit the scroll event as scrollDisp. This is used
	* to avoid unwanted events being handled by the viewport when the event was triggered from the
	* viewport originally.
	*/
	scrollDisp=function(int disp0) {
		auto disp=disp0
		auto available_lines=(this.ybase-this.ydisp)
		if available_lines<0:
			available_lines+=this.scrollback
		if (disp < 0) {
			auto ytop=(this.n_valid_lines<this.scrollback?0:(this.ybase+this.rows)%this.scrollback)
			auto available_lines_neg=(this.ydisp-ytop+this.scrollback)%this.scrollback
			if disp<-available_lines_neg:
				disp=-available_lines_neg
			this.userScrolling=true;
		} else if (disp >= available_lines) {
			disp=available_lines
			this.userScrolling=false;
		}
	
		this.ydisp += disp+this.scrollback;
		this.ydisp%=this.scrollback
	
		//if (!suppressScrollEvent) {
		//	this.emit('scroll', this.ydisp);
		//}
	
		//this.refresh(0, this.rows - 1);
	};
	
	/**
	* Scroll the display of the terminal by a number of pages.
	* @param {number} pageCount The number of pages to scroll (negative scrolls up).
	*/
	scrollPages=function(int pageCount) {
		this.scrollDisp(pageCount * (this.rows - 1));
	}
	
	/**
	* Scrolls the display of the terminal to the top.
	*/
	scrollToTop=function() {
		this.scrollDisp(-this.scrollback);
	}
	
	/**
	* Scrolls the display of the terminal to the bottom.
	*/
	scrollToBottom=function() {
		this.scrollDisp(this.scrollback);
	}
	
	/// parse the last line written
	JSContext JS
	s_parse_buffer=new char[MAX_PARSABLE_LINE*3]
	progress_value=-1.f
	has_progress=0
	parseLastLine=function(){
		auto row=this.y + this.ybase;
		if row>=this.scrollback:
			row-=this.scrollback
		auto row0=row
		auto ytop=(this.n_valid_lines<this.scrollback?0:(this.ybase+this.rows)%this.scrollback)
		//seek to the start of the line, if we have exceeded the counter, ignore the line instead
		auto counter=0
		while row!=ytop:
			auto y0next=row-1
			if y0next<0:
				y0next+=this.scrollback
			if y0next>=this.line_end_states.n||this.line_end_states[y0next]==0:
				break
			row=y0next
			counter+=this.cols
			if counter>=MAX_PARSABLE_LINE:break
		if counter>=MAX_PARSABLE_LINE:return
		this.s_parse_buffer.n=0
		row_initial=row
		for(;;)
			for i=0:this.cols-1
				auto addr=(row*this.cols+i)*3
				if addr+2<this.lines.n&&this.lines[addr+2]:
					this.s_parse_buffer.PushUnicode(this.lines[addr+1])
			if row==row0:break
			row++
			if row>=this.scrollback:
				row-=this.scrollback
		if this.s_parse_buffer.n:
			//this... should always be the terminal object
			this.s_parse_buffer.push('\n')
			is_compiler_error=JS["UI"].CallMethod(int,"ParseTerminalOutput",this,this.s_parse_buffer,0)
			if is_compiler_error:
				row=row_initial
				for(;;)
					for i=0:this.cols-1
						auto addr=(row*this.cols+i)*3
						if addr+2<this.lines.n&&this.lines[addr+2]:
							this.lines[addr+0]|=g_flags.UNDERLINE<<18
					if row==row0:break
					row++
					if row>=this.scrollback:
						row-=this.scrollback
	}
	
	/**
	* Writes text to the g_
	* @param {string} text The text to write to the g_
	*/
	write=function(string data0) {
		if(!this.writable){return;}
		if this.selecting>0:
			//freeze the terminal temporarily when selecting stuff
			if !this.s_lingering:
				this.s_lingering=new string
			this.s_lingering.push(data0)
			return
		this.need_update=1
		auto data=data0;
		auto l=data.n, i=0, j, cs, ch, code, low, ch_width, row;
	
		// apply leftover half-UTF8 or surrogate high from the last write
		if (this.s_lingering) {
			data= this.s_lingering + data;
			this.s_lingering=string.NULL;
		}
	
		pchop=data.n
		for i=data.n-1:-1:max(0,data.n-8)
			c0mask=(int(u32(u8(data[i])))&0xc0)
			if c0mask==0x80:
				//do nothing
			else if c0mask==0xc0:
				lg=2
				if c0mask&0x20:
					lg++
					if c0mask&0x10:
						lg++
				pchop=i
				if pchop+lg<=data.n:
					//if it's a complete char, check for UTF-16 surrogate pairs
					if lg==3:
						ch=((int(u32(u8(data[i])))&0xf)<<12)+((int(u32(u8(data[i+1])))&63)<<6)+(int(u32(u8(data[i+2])))&63)
						if u32(ch-0xd800)<0x800u:
							//1st surrogate, we need to *chop it anyway*
							lg=0
					//otherwise, don't chop it
					pchop+=lg
				break
			else
				pchop=i+1
				break
		if pchop<data.n:
			this.s_lingering=new(data[pchop:])
			data.n=pchop
		for code in Gui2D.Utf8Chars(data) {
			switch (this.state) {
				case normal_state:
					switch (code) {
						case '\x07':
							this.bell();
							break;
						// '\n', '\v', '\f'
						case '\n','\x0b','\x0c':
							if code=='\n':
								//trigger parsing
								this.parseLastLine()
							if (this.convertEol) {
								this.x=0;
							}
							this.y++;
							if (this.y > this.scrollBottom) {
								this.y--;
								this.scroll();
							}
							if this.has_progress:
								this.has_progress=0
								this.progress_value=-1.f
							break;
	
						// '\r'
						case '\r':
							//check for percentage
							//if this.OnProgress:
							auto row=this.y + this.ybase;
							if row>=this.scrollback:
								row-=this.scrollback
							auto pcurchar=(row*this.cols)*3;
							if pcurchar<this.lines.n:
								ppercent=-1
								for j=this.x-1:-1:-1
									if j>=0:
										ch_j=this.lines[pcurchar+j*3+1]
										w_char_j=this.lines[pcurchar+j*3+2]
									else
										ch_j=0
										w_char_j=0
									if ch_j=='%'&&w_char_j:
										ppercent=j
									else if ppercent>0&&(ch_j==' '||ch_j=='\t'||!w_char_j):
										this.s_parse_buffer.n=0
										for j2=j+1:ppercent-1
											ch_j2=this.lines[pcurchar+j2*3+1]
											if ch_j2>='0'&&ch_j2<='9'||ch_j2=='.':
												this.s_parse_buffer.push(char(ch_j2))
											else
												this.s_parse_buffer.n=0
												break
										if this.s_parse_buffer.n>0:
											progress=this.s_parse_buffer.as(float)/100.f
											if progress>=0.f&&progress<=1.f:
												this.has_progress=1
												this.progress_value=progress
												//this.onProgress(progress)
												break
							this.x=0;
							break;
	
						// '\b'
						case '\x08':
							if (this.x > 0) {
								this.x--;
							}
							break;
	
						// '\t'
						case '\t':
							//note: \t beyond cols would have been dropped...
							auto x0=this.x
							this.x=this.nextStop(this.x);
							if x0<this.cols&&this.x>x0:
								//put up a tab char for selection
								row=this.y + this.ybase;
								if row>=this.scrollback:
									row-=this.scrollback
								this.requestLines(row+1)
								auto pcurchar=(row*this.cols+x0)*3;
								this.lines[pcurchar+0]=this.curAttr
								this.lines[pcurchar+1]=9
								this.lines[pcurchar+2]=this.x-x0
							break;
	
						// shift out
						case '\x0e':
							this.setgLevel(1);
							break;
	
						// shift in
						case '\x0f':
							this.setgLevel(0);
							break;
	
						// '\e'
						case '\x1b':
							this.state=escaped;
							break;
	
						default:
							// ' '
							// calculate print space
							// expensive call, therefore we save width in line buffer
							ch_width=wcwidth(code);
	
							if (code >= 32) {
								if (this.charset ) {
									code2=this.charset[code]
									if code2:
										code=code2;
										ch_width=wcwidth(code);
								}
	
								row=this.y + this.ybase;
								if row>=this.scrollback:
									row-=this.scrollback
	
								// insert combining char in last cell
								// FIXME: needs handling after cursor jumps
								//coulddo: combining chars - we don't want strings in cells...
								//if (!ch_width && this.x) {
								//	// dont overflow left
								//	if (this.lines.get(row)[this.x-1]) {
								//		if (!this.lines.get(row)[this.x-1][2]) {
	
								//			// found empty cell after fullwidth, need to go 2 cells back
								//			if (this.lines.get(row)[this.x-2])
								//				this.lines.get(row)[this.x-2][1] += code;
	
								//		} else {
								//			this.lines.get(row)[this.x-1][1] += code;
								//		}
								//		this.updateRange(this.y);
								//	}
								//	break;
								//}
	
								// goto next line if ch would overflow
								if (this.x+ch_width-1 >= this.cols) {
									// autowrap - DECAWM
									if (this.wraparoundMode) {
										//this line has wrapped, update the ending state
										this.line_end_states[row]=1
										this.x=0;
										this.y++;
										if (this.y > this.scrollBottom) {
											this.y--;
											this.scroll();
										}
									} else {
										this.x=this.cols-1;
										if(ch_width==2)  // FIXME: check for xterm behavior
											continue;
									}
								}
								row=this.y + this.ybase;
								if row>=this.scrollback:
									row-=this.scrollback
								this.requestLines(row+1)
	
								// insert mode: move characters to right
								if (this.insertMode) {
									// do this twice for a fullwidth char
									auto addr=this.lines.d+(row*this.cols+this.x)*(3*sizeof(int))
									__basic_api.memmove(
										__pointer(addr+ch_width*(3*sizeof(int))),
										__pointer(addr),
										max(this.cols-this.x-ch_width,0)*(3*sizeof(int)))
									//remove dangling wide chars
									auto plastchar=((row+1)*this.cols-1)*3
									if this.lines[plastchar+2]==2:
										this.lines[plastchar+1]=32
										this.lines[plastchar+2]=0
								}
	
								auto pcurchar=(row*this.cols+this.x)*3;
								this.lines[pcurchar+0]=this.curAttr
								this.lines[pcurchar+1]=code
								this.lines[pcurchar+2]=ch_width;
								this.x++;
								
								// fullwidth char - set next cell width to zero and advance cursor
								if (ch_width==2) {
									this.lines[pcurchar+3]=this.curAttr
									this.lines[pcurchar+4]=32
									this.lines[pcurchar+5]=0
									this.x++;
								}
							}
							break;
					}
					break;
				case escaped:
					switch (code) {
						// ESC [ Control Sequence Introducer ( CSI is 0x9b).
						case '[':
							this.params.clear();
							this.currentParam=0;
							this.state=csi;
							break;
	
						// ESC ] Operating System Command ( OSC is 0x9d).
						case ']':
							this.params.clear();
							this.currentParam=0;
							this.state=osc;
							break;
	
						// ESC P Device Control String ( DCS is 0x90).
						case 'P':
							this.params.clear();
							this.currentParam=0;
							this.state=dcs;
							break;
	
						// ESC _ Application Program Command ( APC is 0x9f).
						case '_':
							this.state=ignore;
							break;
	
						// ESC ^ Privacy Message ( PM is 0x9e).
						case '^':
							this.state=ignore;
							break;
	
						// ESC c Full Reset (RIS).
						case 'c':
							this.reset();
							break;
	
						// ESC E Next Line ( NEL is 0x85).
						// ESC D Index ( IND is 0x84).
						case 'E':
							this.x=0;
							;
						case 'D':
							this.index();
							break;
	
						// ESC M Reverse Index ( RI is 0x8d).
						case 'M':
							this.reverseIndex();
							break;
	
						// ESC % Select default/utf-8 character set.
						// @=default, G=utf-8
						case '%':
							//this.charset=null;
							this.setgLevel(0);
							this.setgCharset(0, g_charsets.US);
							this.state=normal_state;
							i++;
							break;
	
						// ESC (,),*,+,-,. Designate G0-G2 Character Set.
						case '(': // <-- this seems to get all the attention
						case ')':
						case '*':
						case '+':
						case '-':
						case '.':
							switch (code) {
								case '(':
									this.gcharset=0;
									break;
								case ')':
									this.gcharset=1;
									break;
								case '*':
									this.gcharset=2;
									break;
								case '+':
									this.gcharset=3;
									break;
								case '-':
									this.gcharset=1;
									break;
								case '.':
									this.gcharset=2;
									break;
							}
							this.state=charset_state;
							break;
	
						// Designate G3 Character Set (VT300).
						// A=ISO Latin-1 Supplemental.
						// Not implemented.
						case '/':
							this.gcharset=3;
							this.state=charset_state;
							i--;
							break;
	
						// ESC N
						// Single Shift Select of G2 Character Set
						// ( SS2 is 0x8e). This affects next character only.
						case 'N':
							break;
						// ESC O
						// Single Shift Select of G3 Character Set
						// ( SS3 is 0x8f). This affects next character only.
						case 'O':
							break;
						// ESC n
						// Invoke the G2 Character Set as GL (LS2).
						case 'n':
							this.setgLevel(2);
							break;
						// ESC o
						// Invoke the G3 Character Set as GL (LS3).
						case 'o':
							this.setgLevel(3);
							break;
						// ESC |
						// Invoke the G3 Character Set as GR (LS3R).
						case '|':
							this.setgLevel(3);
							break;
						// ESC }
						// Invoke the G2 Character Set as GR (LS2R).
						case '}':
							this.setgLevel(2);
							break;
						// ESC ~
						// Invoke the G1 Character Set as GR (LS1R).
						case '~':
							this.setgLevel(1);
							break;
	
						// ESC 7 Save Cursor (DECSC).
						case '7':
							this.saveCursor();
							this.state=normal_state;
							break;
	
						// ESC 8 Restore Cursor (DECRC).
						case '8':
							this.restoreCursor();
							this.state=normal_state;
							break;
	
						// ESC # 3 DEC line height/width
						case '#':
							this.state=normal_state;
							i++;
							break;
	
						// ESC H Tab Set (HTS is 0x88).
						case 'H':
							this.tabSet();
							break;
	
						// ESC=Application Keypad (DECKPAM).
						case '=':
							//this.log('Serial port requested application keypad.');
							this.applicationKeypad=true;
							//this.viewport.syncScrollArea();
							this.state=normal_state;
							break;
	
						// ESC > Normal Keypad (DECKPNM).
						case '>':
							//this.log('Switching back to normal keypad.');
							this.applicationKeypad=false;
							//this.viewport.syncScrollArea();
							this.state=normal_state;
							break;
	
						default:
							this.state=normal_state;
							//this.error('Unknown ESC control: %s.', code);
							break;
					}
					break;
	
				case charset_state:
					switch (code) {
						case '0': // DEC Special Character and Line Drawing Set.
							cs=g_charsets.SCLD;
							break;
						case 'A': // UK
							cs=g_charsets.UK;
							break;
						case 'B': // United States (USASCII).
							cs=g_charsets.US;
							break;
						case '4': // Dutch
							cs=g_charsets.Dutch;
							break;
						case 'C': // Finnish
						case '5':
							cs=g_charsets.Finnish;
							break;
						case 'R': // French
							cs=g_charsets.French;
							break;
						case 'Q': // FrenchCanadian
							cs=g_charsets.FrenchCanadian;
							break;
						case 'K': // German
							cs=g_charsets.German;
							break;
						case 'Y': // Italian
							cs=g_charsets.Italian;
							break;
						case 'E': // NorwegianDanish
						case '6':
							cs=g_charsets.NorwegianDanish;
							break;
						case 'Z': // Spanish
							cs=g_charsets.Spanish;
							break;
						case 'H': // Swedish
						case '7':
							cs=g_charsets.Swedish;
							break;
						case '=': // Swiss
							cs=g_charsets.Swiss;
							break;
						case '/': // ISOLatin (actually /A)
							cs=g_charsets.ISOLatin;
							i++;
							break;
						default: // Default
							cs=g_charsets.US;
							break;
					}
					this.setgCharset(this.gcharset, cs);
					this.gcharset=0;
					this.state=normal_state;
					break;
	
				case osc:
					// OSC Ps ; Pt ST
					// OSC Ps ; Pt BEL
					//   Set Text Parameters.
					if (code == '\x1b' || code == '\x07') {
						if (code == '\x1b') i++;
	
						//this.params.push(this.currentParam);
						if !this.params.n:
							this.params.push(0)
	
						switch (this.params[0]) {
							case 0,1,2:
								if (this.currentStringParam.n) {
									this.title=this.currentStringParam;
								}
								break;
							case 3:
								// set X property
								break;
							case 4:
							case 5:
								// change dynamic colors
								break;
							case 10:
							case 11:
							case 12:
							case 13:
							case 14:
							case 15:
							case 16:
							case 17:
							case 18:
							case 19:
								// change dynamic ui colors
								break;
							case 46:
								// change log file
								break;
							case 50:
								// dynamic font
								break;
							case 51:
								// emacs shell
								break;
							case 52:
								// manipulate selection data
								break;
							case 104:
							case 105:
							case 110:
							case 111:
							case 112:
							case 113:
							case 114:
							case 115:
							case 116:
							case 117:
							case 118:
								// reset colors
								break;
						}
	
						this.params.clear();
						this.currentParam=0;
						this.state=normal_state;
					} else {
						if (!this.params.n) {
							if (code >= '0' && code <= '9') {
								this.currentParam =
									this.currentParam * 10 + code - 48;
							} else if (code == ';') {
								this.params.push(this.currentParam);
								this.currentStringParam.clear();
							}
						} else {
							this.currentStringParam.PushUnicode(code)
						}
					}
					break;
	
				case csi:
					// '?', '>', '!'
					if (code == '?' || code == '>' || code == '!') {
						this.prefix.clear()
						this.prefix.PushUnicode(code)
						break;
					}
	
					// 0 - 9
					if (code >= '0' && code <= '9') {
						this.currentParam=this.currentParam * 10 + code - 48;
						break;
					}
	
					// '$', '"', ' ', '\''
					//if (code == '$' || code == '"' || code == ' ' || code == '\'') {
					//	this.postfix=code;
					//	break;
					//}
	
					this.params.push(this.currentParam);
					this.currentParam=0;
	
					// ';'
					if (code == ';') break;
	
					this.state=normal_state;
	
					switch (code) {
						// CSI Ps A
						// Cursor Up Ps Times (default=1) (CUU).
						case 'A':
							this.cursorUp(this.params);
							break;
	
						// CSI Ps B
						// Cursor Down Ps Times (default=1) (CUD).
						case 'B':
							this.cursorDown(this.params);
							break;
	
						// CSI Ps C
						// Cursor Forward Ps Times (default=1) (CUF).
						case 'C':
							this.cursorForward(this.params);
							break;
	
						// CSI Ps D
						// Cursor Backward Ps Times (default=1) (CUB).
						case 'D':
							this.cursorBackward(this.params);
							break;
	
						// CSI Ps ; Ps H
						// Cursor Position [row;column] (default=[1,1]) (CUP).
						case 'H':
							this.cursorPos(this.params);
							break;
	
						// CSI Ps J  Erase in Display (ED).
						case 'J':
							this.eraseInDisplay(this.params);
							break;
	
						// CSI Ps K  Erase in Line (EL).
						case 'K':
							this.eraseInLine(this.params);
							break;
	
						// CSI Pm m  Character Attributes (SGR).
						case 'm':
							if (!this.prefix.n) {
								this.charAttributes(this.params);
							}
							break;
	
						// CSI Ps n  Device Status Report (DSR).
						case 'n':
							if (!this.prefix.n) {
								this.deviceStatus(this.params);
							}
							break;
	
							/**
							* Additions
							*/
	
						// CSI Ps @
						// Insert Ps (Blank) Character(s) (default=1) (ICH).
						case '@':
							this.insertChars(this.params);
							break;
	
						// CSI Ps E
						// Cursor Next Line Ps Times (default=1) (CNL).
						case 'E':
							this.cursorNextLine(this.params);
							break;
	
						// CSI Ps F
						// Cursor Preceding Line Ps Times (default=1) (CNL).
						case 'F':
							this.cursorPrecedingLine(this.params);
							break;
	
						// CSI Ps G
						// Cursor Character Absolute  [column] (default=[row,1]) (CHA).
						case 'G':
							this.cursorCharAbsolute(this.params);
							break;
	
						// CSI Ps L
						// Insert Ps Line(s) (default=1) (IL).
						case 'L':
							this.insertLines(this.params);
							break;
	
						// CSI Ps M
						// Delete Ps Line(s) (default=1) (DL).
						case 'M':
							this.deleteLines(this.params);
							break;
	
						// CSI Ps P
						// Delete Ps Character(s) (default=1) (DCH).
						case 'P':
							this.deleteChars(this.params);
							break;
	
						// CSI Ps X
						// Erase Ps Character(s) (default=1) (ECH).
						case 'X':
							this.eraseChars(this.params);
							break;
	
						// CSI Pm `  Character Position Absolute
						//   [column] (default=[row,1]) (HPA).
						case '`':
							this.charPosAbsolute(this.params);
							break;
	
						// 141 61 a * HPR -
						// Horizontal Position Relative
						case 'a':
							this.HPositionRelative(this.params);
							break;
	
						// CSI P s c
						// Send Device Attributes (Primary DA).
						// CSI > P s c
						// Send Device Attributes (Secondary DA)
						case 'c':
							this.sendDeviceAttributes(this.params);
							break;
	
						// CSI Pm d
						// Line Position Absolute  [row] (default=[1,column]) (VPA).
						case 'd':
							this.linePosAbsolute(this.params);
							break;
	
						// 145 65 e * VPR - Vertical Position Relative
						case 'e':
							this.VPositionRelative(this.params);
							break;
	
						// CSI Ps ; Ps f
						//   Horizontal and Vertical Position [row;column] (default =
						//   [1,1]) (HVP).
						case 'f':
							this.HVPosition(this.params);
							break;
	
						// CSI Pm h  Set Mode (SM).
						// CSI ? Pm h - mouse escape codes, cursor escape codes
						case 'h':
							this.setMode(this.params);
							break;
	
						// CSI Pm l  Reset Mode (RM).
						// CSI ? Pm l
						case 'l':
							this.resetMode(this.params);
							break;
	
						// CSI Ps ; Ps r
						//   Set Scrolling Region [top;bottom] (default=full size of win-
						//   dow) (DECSTBM).
						// CSI ? Pm r
						case 'r':
							this.setScrollRegion(this.params);
							break;
	
						// CSI s
						//   Save cursor (ANSI.SYS).
						case 's':
							this.saveCursor();
							break;
	
						// CSI u
						//   Restore cursor (ANSI.SYS).
						case 'u':
							this.restoreCursor();
							break;
	
							/**
							* Lesser Used
							*/
	
						// CSI Ps I
						// Cursor Forward Tabulation Ps tab stops (default=1) (CHT).
						case 'I':
							this.cursorForwardTab(this.params);
							break;
	
						// CSI Ps S  Scroll up Ps lines (default=1) (SU).
						case 'S':
							this.scrollUp(this.params);
							break;
	
						// CSI Ps T  Scroll down Ps lines (default=1) (SD).
						// CSI Ps ; Ps ; Ps ; Ps ; Ps T
						// CSI > Ps; Ps T
						case 'T':
							// if (this.prefix == '>') {
							//   this.resetTitleModes(this.params);
							//   break;
							// }
							// if (this.params.n > 2) {
							//   this.initMouseTracking(this.params);
							//   break;
							// }
							if (this.params.n < 2 && !this.prefix.n) {
								this.scrollDown(this.params.n>0?this.params[0]:1);
							}
							break;
	
						// CSI Ps Z
						// Cursor Backward Tabulation Ps tab stops (default=1) (CBT).
						case 'Z':
							this.cursorBackwardTab(this.params);
							break;
	
						// CSI Ps b  Repeat the preceding graphic character Ps times (REP).
						case 'b':
							this.repeatPrecedingCharacter(this.params);
							break;
	
						// CSI Ps g  Tab Clear (TBC).
						case 'g':
							this.tabClear(this.params);
							break;
	
							// CSI Pm i  Media Copy (MC).
							// CSI ? Pm i
							// case 'i':
							//   this.mediaCopy(this.params);
							//   break;
	
							// CSI Pm m  Character Attributes (SGR).
							// CSI > Ps; Ps m
							// case 'm': // duplicate
							//   if (this.prefix == '>') {
							//     this.setResources(this.params);
							//   } else {
							//     this.charAttributes(this.params);
							//   }
							//   break;
	
							// CSI Ps n  Device Status Report (DSR).
							// CSI > Ps n
							// case 'n': // duplicate
							//   if (this.prefix == '>') {
							//     this.disableModifiers(this.params);
							//   } else {
							//     this.deviceStatus(this.params);
							//   }
							//   break;
	
							// CSI > Ps p  Set pointer mode.
							// CSI ! p   Soft terminal reset (DECSTR).
							// CSI Ps$ p
							//   Request ANSI mode (DECRQM).
							// CSI ? Ps$ p
							//   Request DEC private mode (DECRQM).
							// CSI Ps ; Ps " p
						case 'p':
							if this.prefix=="!":
								this.softReset(this.params);
							break;
	
							// CSI Ps q  Load LEDs (DECLL).
							// CSI Ps SP q
							// CSI Ps " q
							// case 'q':
							//   if (this.postfix == ' ') {
							//     this.setCursorStyle(this.params);
							//     break;
							//   }
							//   if (this.postfix == '"') {
							//     this.setCharProtectionAttr(this.params);
							//     break;
							//   }
							//   this.loadLEDs(this.params);
							//   break;
	
							// CSI Ps ; Ps r
							//   Set Scrolling Region [top;bottom] (default=full size of win-
							//   dow) (DECSTBM).
							// CSI ? Pm r
							// CSI Pt; Pl; Pb; Pr; Ps$ r
							// case 'r': // duplicate
							//   if (this.prefix == '?') {
							//     this.restorePrivateValues(this.params);
							//   } else if (this.postfix == '$') {
							//     this.setAttrInRectangle(this.params);
							//   } else {
							//     this.setScrollRegion(this.params);
							//   }
							//   break;
	
							// CSI s     Save cursor (ANSI.SYS).
							// CSI ? Pm s
							// case 's': // duplicate
							//   if (this.prefix == '?') {
							//     this.savePrivateValues(this.params);
							//   } else {
							//     this.saveCursor(this.params);
							//   }
							//   break;
	
							// CSI Ps ; Ps ; Ps t
							// CSI Pt; Pl; Pb; Pr; Ps$ t
							// CSI > Ps; Ps t
							// CSI Ps SP t
							// case 't':
							//   if (this.postfix == '$') {
							//     this.reverseAttrInRectangle(this.params);
							//   } else if (this.postfix == ' ') {
							//     this.setWarningBellVolume(this.params);
							//   } else {
							//     if (this.prefix == '>') {
							//       this.setTitleModeFeature(this.params);
							//     } else {
							//       this.manipulateWindow(this.params);
							//     }
							//   }
							//   break;
	
							// CSI u     Restore cursor (ANSI.SYS).
							// CSI Ps SP u
							// case 'u': // duplicate
							//   if (this.postfix == ' ') {
							//     this.setMarginBellVolume(this.params);
							//   } else {
							//     this.restoreCursor(this.params);
							//   }
							//   break;
	
							// CSI Pt; Pl; Pb; Pr; Pp; Pt; Pl; Pp$ v
							// case 'v':
							//   if (this.postfix == '$') {
							//     this.copyRectagle(this.params);
							//   }
							//   break;
	
							// CSI Pt ; Pl ; Pb ; Pr ' w
							// case 'w':
							//   if (this.postfix == '\'') {
							//     this.enableFilterRectangle(this.params);
							//   }
							//   break;
	
							// CSI Ps x  Request Terminal Parameters (DECREQTPARM).
							// CSI Ps x  Select Attribute Change Extent (DECSACE).
							// CSI Pc; Pt; Pl; Pb; Pr$ x
							// case 'x':
							//   if (this.postfix == '$') {
							//     this.fillRectangle(this.params);
							//   } else {
							//     this.requestParameters(this.params);
							//     //this.__(this.params);
							//   }
							//   break;
	
							// CSI Ps ; Pu ' z
							// CSI Pt; Pl; Pb; Pr$ z
							// case 'z':
							//   if (this.postfix == '\'') {
							//     this.enableLocatorReporting(this.params);
							//   } else if (this.postfix == '$') {
							//     this.eraseRectangle(this.params);
							//   }
							//   break;
	
							// CSI Pm ' {
							// CSI Pt; Pl; Pb; Pr$ {
							// case '{':
							//   if (this.postfix == '\'') {
							//     this.setLocatorEvents(this.params);
							//   } else if (this.postfix == '$') {
							//     this.selectiveEraseRectangle(this.params);
							//   }
							//   break;
	
							// CSI Ps ' |
							// case '|':
							//   if (this.postfix == '\'') {
							//     this.requestLocatorPosition(this.params);
							//   }
							//   break;
	
							// CSI P m SP }
							// Insert P s Column(s) (default=1) (DECIC), VT420 and up.
							// case '}':
							//   if (this.postfix == ' ') {
							//     this.insertColumns(this.params);
							//   }
							//   break;
	
							// CSI P m SP ~
							// Delete P s Column(s) (default=1) (DECDC), VT420 and up
							// case '~':
							//   if (this.postfix == ' ') {
							//     this.deleteColumns(this.params);
							//   }
							//   break;
	
						default:
							//this.error('Unknown CSI code: %s.', code);
							break;
					}
	
					this.prefix.clear();
					//this.postfix='';
					break;
	
				case dcs:
					if (code == '\x1b' || code == '\x07') {
						if (code == '\x1b') i++;
	
						if(!this.prefix||!this.prefix.n)
							// User-Defined Keys (DECUDK).
						else if(this.prefix=='$q')
							// Request Status String (DECRQSS).
							// test: echo -e '\eP$q"p\e\\'
							auto pt=this.currentStringParam, valid=false;
							if pt=='"q':
								// DECSCA
								pt='0"q';
							else if pt=='"p':
								// DECSCL
								pt='61"p';
							// DECSTBM
							else if pt=="r":
								pt=FormatAsText(this.scrollTop + 1,';',this.scrollBottom + 1,'r')
							// SGR
							else if pt=="m":
								pt='0m';
							else
								//this.error('Unknown DCS Pt: %s.', pt);
								pt='';
							this.send(FormatAsText('\x1bP',!!valid,'$r',pt,'\x1b\\'));
							break;
						else if(this.prefix=='+p')
							// Set Termcap/Terminfo Data (xterm, experimental).
						else if(this.prefix=='+q')
							// Request Termcap/Terminfo String (xterm, experimental)
							// Regular xterm does not even respond to this sequence.
							// This can cause a small glitch in vim.
							// test: echo -ne '\eP+q6b64\e\\'
							auto pt=this.currentStringParam, valid=false;
							this.send(FormatAsText('\x1bP',!!valid,'+r',pt,'\x1b\\'));
	
						this.currentStringParam.clear();
						this.prefix.clear();
						this.state=normal_state;
					} else if (!this.currentStringParam.n) {
						if (!this.prefix && code != '$' && code != '+') {
							this.currentStringParam.PushUnicode(code);
						} else if (this.prefix.n == 2) {
							this.currentStringParam.PushUnicode(code);
						} else {
							this.prefix.PushUnicode(code);
						}
					} else {
						this.currentStringParam.PushUnicode(code);
					}
					break;
	
				case ignore:
					// For PM and APC.
					if (code == '\x1b' || code == '\x07') {
						if (code == '\x1b') i++;
						this.state=normal_state;
					}
					break;
			}
		}
	
		//this.refresh(this.refreshStart, this.refreshEnd);
	};
	
	flushQueuedWrites=inline(){
		if this.s_lingering:
			auto data=this.s_lingering
			this.s_lingering=string.NULL
			this.write(data)
	}
	
	/**
	* Writes text to the terminal, followed by a break line character (\n).
	* @param {string} text The text to write to the g_
	*/
	//Terminal_prototype.writeln=function(data) {
	//	this.write(data + '\r\n');
	//};
	
	/**
	* Attaches a custom keydown handler which is run before keys are processed, giving consumers of
	* xterm.js ultimate control as to what keys should be processed by the terminal and what keys
	* should not.
	* @param {function} customKeydownHandler The custom KeyboardEvent handler to attach. This is a
	*   function that takes a KeyboardEvent, allowing consumers to stop propogation and/or prevent
	*   the default action. The function returns whether the event should be processed by xterm.js.
	*/
	//Terminal_prototype.attachCustomKeydownHandler=function(customKeydownHandler) {
	//	this.customKeydownHandler=customKeydownHandler;
	//}
	
	confirmCopy=function(JS){
		if !this.selecting:return
		auto sel_x0=this.sel_x0
		auto sel_y0=this.sel_y0
		auto sel_x1=this.sel_x1
		auto sel_y1=this.sel_y1
		auto ytop=(this.n_valid_lines<this.scrollback?0:(this.ybase+this.rows)%this.scrollback)
		sel_y0=(sel_y0+this.scrollback-ytop)%this.scrollback
		sel_y1=(sel_y1+this.scrollback-ytop)%this.scrollback
		if sel_y0>sel_y1||sel_y0==sel_y1&&sel_x0>sel_x1:
			tmp=sel_x0;sel_x0=sel_x1;sel_x1=tmp
			tmp=sel_y0;sel_y0=sel_y1;sel_y1=tmp
		auto stext=new string
		for j=sel_y0:sel_y1
			row=(ytop+j)%this.scrollback
			sel_x0_j=this.cols
			sel_x1_j=0
			if j==sel_y0:
				sel_x0_j=sel_x0
			else if j>sel_y0:
				sel_x0_j=0
			if j==sel_y1:
				sel_x1_j=sel_x1
			else if j<sel_y1:
				sel_x1_j=this.cols
			for i=sel_x0_j:sel_x1_j-1
				auto addr=(row*this.cols+i)*3
				if addr+2<this.lines.n&&this.lines[addr+2]:
					stext.PushUnicode(this.lines[addr+1])
			if row<this.line_end_states.n&&this.line_end_states[row]==0:
				has_newline=1
				for i=sel_x1_j:this.cols-1
					auto addr=(row*this.cols+i)*3
					if addr+2<this.lines.n&&this.lines[addr+2]:
						has_newline=0
						break
				if has_newline:
					stext.push('\n')
		stext.push(char(0))
		SDL.detail.SDL_SetClipboardText(stext)
		stext.discard()
		if this.selecting==1:
			js_this=JS.GetThis()
			JS["UI"].CallMethod(int,"ReleaseMouse",js_this)
		this.selecting=0
	}
	
	/**
	* Handle a keydown event
	* Key Resources:
	*   - https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
	* @param {KeyboardEvent} ev The keydown event to be handled.
	*/
	keyDown=function(JS,ev) {
		auto result=this.evaluateKeyEscapeSequence(ev);
		
		if (result.scrollDisp) {
			this.scrollDisp(result.scrollDisp);
			return 1;
		}

		auto keymod=ev["keymod"].or(0)
		auto shiftKey=!!(keymod&KMOD_SHIFT)
		auto altKey=!!(keymod&KMOD_ALT)
		auto ctrlKey=!!(keymod&KMOD_CTRL)
		auto metaKey=!!(keymod&KMOD_WIN)
		auto keyCode=ev["keysym"].as(int)
		if this.selecting>0:
			if !keymod&&(keyCode==13||keyCode==1073741982)||keymod==KMOD_CTRL&&keyCode==99:
				//return / ctrl+c - copy text and cancel sel
				//SDL.detail.SDL_SetClipboardText()
				this.confirmCopy(JS)
				return 1
			if keyCode==27:
				//esc, cancel sel
				this.selecting=0
				return 1
			return 0
	
		auto thirdLevelKey = (
				(Platform.IS_APPLE && altKey && !ctrlKey && !metaKey) ||
				(Platform.IS_WINDOWS && altKey && ctrlKey && !metaKey));
		// Don't invoke for arrows, pageDown, home, backspace, etc. (on non-keypress events)
		if (thirdLevelKey && (!keyCode || keyCode > 47)) {
			return 0;
		}
	
		//if (result.cancel) {
		//	// The event is canceled at the end already, is this necessary?
		//	this.cancel(ev, true);
		//}
	
		if (!result.key) {
			return 0;
		}
	
		if this.download_buf:
			if result.key=="\x03":
				//CTRL+C
				this.input_during_download=string.NULL
				this.cancelDownload()
				return 1
			if !this.input_during_download:
				this.input_during_download=new string
			this.input_during_download.push(result.key)
			return 1
		//this.emit('keydown', ev);
		//this.emit('key', result.key, ev);
		this.handler(result.key);
	
		//return this.cancel(ev, true);
		return 1;
	};
	
	/**
	* Returns an object that determines how a KeyboardEvent should be handled. The key of the
	* returned value is the new key code to pass to the PTY.
	*
	* Reference: http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
	* @param {KeyboardEvent} ev The keyboard event to be translated to key escape sequence.
	*/
	evaluateKeyEscapeSequence=function(ev) {
		auto result={
			// Whether to cancel event propogation (NOTE: this may not be needed since the event is
			// canceled at the end of keyDown
			cancel: 0,
			// The new key even to emit
			key: string.NULL,
			// The number of characters to scroll, if this is defined it will cancel the event
			scrollDisp: 0
		};
		keymod=ev["keymod"].or(0)
		auto shiftKey=!!(keymod&KMOD_SHIFT)
		auto altKey=!!(keymod&KMOD_ALT)
		auto ctrlKey=!!(keymod&KMOD_CTRL)
		auto metaKey=!!(keymod&KMOD_WIN)
		auto modifiers=shiftKey << 0 | altKey << 1 | ctrlKey << 2 | metaKey << 3;
		auto keyCode=ev["keysym"].as(int)
		switch (keyCode) {
			case 8:
				// backspace
				if (shiftKey) {
					result.key="\x08"; // ^H
					break;
				}
				result.key="\x7f"; // ^?
				break;
			case 9:
				// tab
				if (shiftKey) {
					result.key="\x1b[Z";
					break;
				}
				result.key="\t";
				result.cancel=true;
				break;
			case 13,1073741982:
				// return/enter
				result.key="\r";
				result.cancel=true;
				this.got_enter_from_input=1;
				break;
			case 27:
				// escape
				result.key="\x1b";
				result.cancel=true;
				break;
			case 1073741904:
				// left-arrow
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;",modifiers + 1, 'D');
					// HACK: Make Alt + left-arrow behave like Ctrl + left-arrow: move one word backwards
					// http://unix.stackexchange.com/a/108106
					// macOS uses different escape sequences than linux
					if (result.key == '\x1b[1;3D') {
						result.key=(Platform.IS_APPLE) ? '\x1bb' : '\x1b[1;5D';
					}
				} else if (this.applicationCursor) {
					result.key="\x1bOD";
				} else {
					result.key="\x1b[D";
				}
				break;
			case 1073741903:
				// right-arrow
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'C');
					// HACK: Make Alt + right-arrow behave like Ctrl + right-arrow: move one word forward
					// http://unix.stackexchange.com/a/108106
					// macOS uses different escape sequences than linux
					if (result.key == '\x1b[1;3C') {
						result.key=(Platform.IS_APPLE) ? '\x1bf' : '\x1b[1;5C';
					}
				} else if (this.applicationCursor) {
					result.key="\x1bOC";
				} else {
					result.key="\x1b[C";
				}
				break;
			case 1073741906:
				// up-arrow
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'A');
					// HACK: Make Alt + up-arrow behave like Ctrl + up-arrow
					// http://unix.stackexchange.com/a/108106
					if (Platform.IS_APPLE&&result.key == '\x1b[1;3A') {
						result.key="\x1b[1;5A";
					}
				} else if (this.applicationCursor) {
					result.key="\x1bOA";
				} else {
					result.key="\x1b[A";
				}
				break;
			case 1073741905:
				// down-arrow
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'B');
					// HACK: Make Alt + down-arrow behave like Ctrl + down-arrow
					// http://unix.stackexchange.com/a/108106
					if (Platform.IS_APPLE&&result.key == '\x1b[1;3B') {
						result.key="\x1b[1;5B";
					}
				} else if (this.applicationCursor) {
					result.key="\x1bOB";
				} else {
					result.key="\x1b[B";
				}
				break;
			case 1073741897:
				// insert
				if (!shiftKey && !ctrlKey) {
					// <Ctrl> or <Shift> + <Insert> are used to
					// copy-paste on some systems.
					result.key="\x1b[2~";
				}
				break;
			case 127:
				// delete
				if (modifiers) {
					result.key=FormatAsText("\x1b[3;", modifiers + 1, '~');
				} else {
					result.key="\x1b[3~";
				}
				break;
			case 1073741898:
				// home
				if (modifiers)
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'H');
				else if (this.applicationCursor)
					result.key="\x1bOH";
				else
					result.key="\x1b[H";
				break;
			case 1073741901:
				// end
				if (modifiers)
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'F');
				else if (this.applicationCursor)
					result.key="\x1bOF";
				else
					result.key="\x1b[F";
				break;
			case 1073741899:
				// page up
				if (shiftKey) {
					result.scrollDisp=-(this.rows - 1);
				} else {
					result.key="\x1b[5~";
				}
				break;
			case 1073741902:
				// page down
				if (shiftKey) {
					result.scrollDisp=this.rows - 1;
				} else {
					result.key="\x1b[6~";
				}
				break;
			case SDLK_Fn+1:
				// F1-F12
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'P');
				} else {
					result.key="\x1bOP";
				}
				break;
			case SDLK_Fn+2:
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'Q');
				} else {
					result.key="\x1bOQ";
				}
				break;
			case SDLK_Fn+3:
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'R');
				} else {
					result.key="\x1bOR";
				}
				break;
			case SDLK_Fn+4:
				if (modifiers) {
					result.key=FormatAsText("\x1b[1;", modifiers + 1, 'S');
				} else {
					result.key="\x1bOS";
				}
				break;
			case SDLK_Fn+5:
				if (modifiers) {
					result.key=FormatAsText("\x1b[15;", modifiers + 1, '~');
				} else {
					result.key="\x1b[15~";
				}
				break;
			case SDLK_Fn+6:
				if (modifiers) {
					result.key=FormatAsText("\x1b[17;", modifiers + 1, '~');
				} else {
					result.key="\x1b[17~";
				}
				break;
			case SDLK_Fn+7:
				if (modifiers) {
					result.key=FormatAsText("\x1b[18;", modifiers + 1, '~');
				} else {
					result.key="\x1b[18~";
				}
				break;
			case SDLK_Fn+8:
				if (modifiers) {
					result.key=FormatAsText("\x1b[19;", modifiers + 1, '~');
				} else {
					result.key="\x1b[19~";
				}
				break;
			case SDLK_Fn+9:
				if (modifiers) {
					result.key=FormatAsText("\x1b[20;", modifiers + 1, '~');
				} else {
					result.key="\x1b[20~";
				}
				break;
			case SDLK_Fn+10:
				if (modifiers) {
					result.key=FormatAsText("\x1b[21;", modifiers + 1, '~');
				} else {
					result.key="\x1b[21~";
				}
				break;
			case SDLK_Fn+11:
				if (modifiers) {
					result.key=FormatAsText("\x1b[23;", modifiers + 1, '~');
				} else {
					result.key="\x1b[23~";
				}
				break;
			case SDLK_Fn+12:
				if (modifiers) {
					result.key=FormatAsText("\x1b[24;", modifiers + 1, '~');
				} else {
					result.key="\x1b[24~";
				}
				break;
			default:
				// a-z and space
				if (ctrlKey && !shiftKey && !altKey && !metaKey) {
					if (keyCode >= 97 && keyCode <= 122) {
						result.key=String_fromCharCode(keyCode - 96);
					} else if (keyCode == 32) {
						// NUL
						result.key=String_fromCharCode(0);
					} else if (keyCode >= 51 && keyCode <= 55) {
						// escape, file sep, group sep, record sep, unit sep
						result.key=String_fromCharCode(keyCode - 51 + 27);
					} else if (keyCode == 56) {
						// delete
						result.key=String_fromCharCode(127);
					} else if (keyCode == 91) {
						// ^[ - Control Sequence Introducer (CSI)
						result.key=String_fromCharCode(27);
					} else if (keyCode == 92) {
						// ^\ - String Terminator (ST)
						result.key=String_fromCharCode(28);
					} else if (keyCode == 93) {
						// ^] - Operating System Command (OSC)
						result.key=String_fromCharCode(29);
					}
				} else if (!Platform.IS_APPLE && altKey && !ctrlKey && !metaKey) {
					// On Mac this is a third level shift. Use <Esc> instead.
					if (keyCode >= 97 && keyCode <= 122) {
						result.key="\x1b" + String_fromCharCode(keyCode);
					} else if (keyCode == 96) {
						// `
						result.key="\x1b`";
					} else if (keyCode >= 48 && keyCode <= 57) {
						result.key=FormatAsText("\x1b",keyCode - 48);
					}
				}
				break;
		}
		return result;
	};
	
	/**
	* Set the G level of the terminal
	* @param g
	*/
	setgLevel=inline(g) {
		this.glevel=g;
		this.charset=this.charsets[g];
	};
	
	/**
	* Set the charset for the given G level of the terminal
	* @param g
	* @param charset
	*/
	setgCharset=function(g, charset) {
		this.charsets[g]=charset;
		if (this.glevel == g) {
			this.charset=charset;
		}
	};
	
	/**
	* Send data for handling to the terminal
	* @param {string} data
	*/
	send=inline(data) {
		//auto self=this;
	
		//if (!this.queue) {
		//	setTimeout(function() {
		//		self.handler(self.queue);
		//		self.queue='';
		//	}, 1);
		//}
	
		//this.queue += data;
		this.handler(data)
	};
	
	onTextInput=function(text){
		//selection won't matter here - it can't possibly be a hotkey, just send it
		//if this.selecting>0:
		//when downloading, though, we have to buffer it
		if this.download_buf:
			if !this.input_during_download:
				this.input_during_download=new string
			this.input_during_download.push(text)
		else
			this.handler(text)
	}
	
	/**
	* Ring the bell.
	* Note: We could do sweet things with webaudio here
	*/
	bell=function() {
		this.bell_tick=System.Time.tick64()+System.Time.SecondsToTicks(VISUAL_BELL_DURATION)
	};
	
	/**
	* Resizes the terminal
	*
	* @param {number} x The number of columns to resize to.
	* @param {number} y The number of rows to resize to.
	*/
	resize=function(x0, y0) {
		auto x=x0;
		auto y=y0
		auto line, el, i, j, ch, addToY;
		if (x == this.cols && y == this.rows) {
			return;
		}
	
		if (x < 2) x=2;
		if (y < 1) y=1;
	
		new_lines=new int[this.n_valid_lines*x*3]
		ncpy=min(this.cols,x)*(3*sizeof(int))
		for i=0:this.n_valid_lines-1
			__basic_api.memcpy(
				__pointer(new_lines.d+i*x*(3*sizeof(int))),
				__pointer(this.lines.d+i*this.cols*(3*sizeof(int))),
				ncpy)
		this.lines.discard()
		this.lines=new_lines
		this.setupStops(j);
		this.cols=x;
	
		// resize rows - add blank lines
		j=this.rows;
		if (j < y) {
			while (j++ < y) {
				// y is rows, not this.y
				row_clear=(this.ybase+j)%this.scrollback
				this.clearWithAttr(row_clear*this.cols,this.defAttr,this.cols)
			}
		} else { // (j > y)
			while (j-- > y) {
				this.ybase++;
				if this.ybase>=this.scrollback:this.ybase=0
				this.ydisp++;
				if this.ydisp>=this.scrollback:this.ydisp=0
			}
		}
		this.rows=y;
	
		// Make sure that the cursor stays on screen
		// how to handle the this.y<0 case?
		if this.y<0:
			this.y=0
		if (this.y >= y) {
			this.y=y - 1;
		}
		if (this.x >= x) {
			this.x=x - 1;
		}
	
		this.scrollTop=0;
		this.scrollBottom=y - 1;
	
		//this.refresh(0, this.rows - 1);
	
		//this.normal=typeof(this.normal).null;
		this.has_normal=0
	
		this.geometry[0]=this.cols
		this.geometry[1]=this.rows
		//this.emit('resize', {terminal: this, cols: x, rows: y});
	};
	
	/**
	* Setup the tab stops.
	* @param {number} i
	*/
	setupStops=function(i0) {
		if !this.tabs:
			this.tabs=new char[this.cols]
		else
			this.tabs.resize(this.cols)
	
		for (i=this.prevStop(i0); i < this.cols; i += 8) {
			this.tabs[i]=char(1);
		}
	};
	
	
	/**
	* Move the cursor to the previous tab stop from the given position (default is current).
	* @param {number} x The position to move the cursor to the previous tab stop.
	*/
	prevStop=function(x0) {
		auto x=x0
		for(;;)
			x--
			if x<0||this.tabs[x]:break
		return x >= this.cols ? this.cols - 1: (x < 0 ? 0 : x);
	};
	
	
	/**
	* Move the cursor one tab stop forward from the given position (default is current).
	* @param {number} x The position to move the cursor one tab stop forward.
	*/
	nextStop=function(x0) {
		auto x=x0
		for(;;)
			x++
			if x>=this.cols||this.tabs[x]:break
		return x >= this.cols? this.cols - 1: (x < 0 ? 0 : x);
	};
	
	
	/**
	* Erase in the identified line everything from "x" to the end of the line (right).
	* @param {number} x The column from which to start erasing to the end of the line.
	* @param {number} y The line in which to operate.
	*/
	eraseRight=function(x, y) {
		if x<this.cols:
			row=(this.ybase+y)%this.scrollback
			this.clearWithAttr(row*this.cols+x,this.eraseAttr(),this.cols-x)
	};
	
	
	
	/**
	* Erase in the identified line everything from "x" to the start of the line (left).
	* @param {number} x The column from which to start erasing to the start of the line.
	* @param {number} y The line in which to operate.
	*/
	eraseLeft=function(x, y) {
		if x>0:
			row=(this.ybase+y)%this.scrollback
			this.clearWithAttr(row*this.cols,this.eraseAttr(),x)
	};
	
	/**
	* Clears the entire buffer, making the prompt line the new first line.
	*/
	//clear=function() {
	//	if (this.ybase == 0 && this.y == 0) {
	//		// Don't clear if it's already clear
	//		return;
	//	}
	//	this.lines.set(0, this.lines.get(this.ybase + this.y));
	//	this.scrollback=1;
	//	this.ydisp=0;
	//	this.ybase=0;
	//	this.y=0;
	//	for (auto i=1; i < this.rows; i++) {
	//		this.lines.push(this.blankLine());
	//	}
	//	//this.refresh(0, this.rows - 1);
	//	this.emit('scroll', this.ydisp);
	//};
	
	/**
	* Erase all content in the given line
	* @param {number} y The line to erase all of its contents.
	*/
	eraseLine=function(y) {
		this.eraseRight(0, y);
	};
	
	
	/**
	* Emit the 'data' event and populate the given data.
	* @param {string} data The data to populate in the event.
	*/
	handler=function(data) {
		if !this.readable:return
		// Input is being sent to the terminal, the terminal should focus the prompt.
		if (this.ybase != this.ydisp) {
			this.scrollToBottom();
		}
		this.OnData(data);
	};
	WriteInput=function(){
		if !proc:return
		auto nwritten=proc.pipe.Write(this.input_pipe_queue)
		if nwritten>0&&nwritten<this.input_pipe_queue.n:
			copy(this.input_pipe_queue[0:],this.input_pipe_queue[nwritten:])
		this.input_pipe_queue.n-=nwritten
		if this.input_pipe_queue.n>0:
			JS["UI"].CallMethod(int,"NextTick",function(JSContext JS){
				WriteInput();
				return 0;
			})
	}
	OnData=function(string s0){
		if !proc||!proc.pipe:return
		this.input_pipe_queue.push(s0)
		WriteInput()
	}
	
	/**
	* ESC
	*/
	
	/**
	* ESC D Index (IND is 0x84).
	*/
	index=function() {
		this.y++;
		if (this.y > this.scrollBottom) {
			this.y--;
			this.scroll();
		}
		this.state=normal_state;
	};
	
	
	/**
	* ESC M Reverse Index (RI is 0x8d).
	*
	* Move the cursor up one row, inserting a new blank line if necessary.
	*/
	reverseIndex=function() {
		auto j;
		if (this.y == this.scrollTop) {
			this.scrollDown(1)
			this.clearWithAttr((this.y + this.ybase)%this.scrollback*this.cols,this.eraseAttr(),this.cols)
			// possibly move the code below to term.reverseScroll();
			// test: echo -ne '\e[1;1H\e[44m\eM\e[0m'
			// blankLine(true) is xterm/linux behavior
			//this.updateRange(this.scrollTop);
			//this.updateRange(this.scrollBottom);
		} else {
			this.y--;
		}
		this.state=normal_state;
	};
	
	
	/**
	* ESC c Full Reset (RIS).
	*/
	reset=function() {
		//auto customKeydownHandler=this.customKeydownHandler;
		this.__init__(this.cols,this.rows)
		//this.customKeydownHandler=customKeydownHandler;
		//this.refresh(0, this.rows - 1);
		//this.viewport.syncScrollArea();
	};
	
	
	/**
	* ESC H Tab Set (HTS is 0x88).
	*/
	tabSet=function() {
		this.tabs[this.x]=true;
		this.state=normal_state;
	};
	
	
	/**
	* CSI
	*/
	
	/**
	* CSI Ps A
	* Cursor Up Ps Times (default=1) (CUU).
	*/
	cursorUp=function(params) {
		auto param=(params.n>0?params[0]:1);
		if (param < 1): param=1;
		this.y -= param;
		if (this.y < 0): this.y=0;
	};
	
	
	/**
	* CSI Ps B
	* Cursor Down Ps Times (default=1) (CUD).
	*/
	cursorDown=function(params) {
		auto param=(params.n>0?params[0]:1);
		if (param < 1): param=1;
		this.y += param;
		if (this.y >= this.rows) {
			this.y=this.rows - 1;
		}
	};
	
	
	/**
	* CSI Ps C
	* Cursor Forward Ps Times (default=1) (CUF).
	*/
	cursorForward=function(params) {
		auto param=(params.n>0?params[0]:1);
		if (param < 1): param=1;
		this.x += param;
		if (this.x >= this.cols) {
			this.x=this.cols - 1;
		}
	};
	
	
	/**
	* CSI Ps D
	* Cursor Backward Ps Times (default=1) (CUB).
	*/
	cursorBackward=function(params) {
		auto param=(params.n>0?params[0]:1);
		if (param < 1): param=1;
		this.x -= param;
		if (this.x < 0): this.x=0;
	};
	
	
	/**
	* CSI Ps ; Ps H
	* Cursor Position [row;column] (default=[1,1]) (CUP).
	*/
	cursorPos=function(params) {
		auto row, col;
	
		row=(params.n>0?params[0]:1) - 1;
	
		if (params.n >= 2) {
			col=params[1] - 1;
		} else {
			col=0;
		}
	
		if (row < 0) {
			row=0;
		} else if (row >= this.rows) {
			row=this.rows - 1;
		}
	
		if (col < 0) {
			col=0;
		} else if (col >= this.cols) {
			col=this.cols - 1;
		}
	
		this.x=col;
		this.y=row;
	};
	
	
	/**
	* CSI Ps J  Erase in Display (ED).
	*     Ps=0  -> Erase Below (default).
	*     Ps=1  -> Erase Above.
	*     Ps=2  -> Erase All.
	*     Ps=3  -> Erase Saved Lines (xterm).
	* CSI ? Ps J
	*   Erase in Display (DECSED).
	*     Ps=0  -> Selective Erase Below (default).
	*     Ps=1  -> Selective Erase Above.
	*     Ps=2  -> Selective Erase All.
	*/
	eraseInDisplay=function(params) {
		auto j;
		switch (params[0]) {
			case 0:
				this.eraseRight(this.x, this.y);
				j=this.y + 1;
				for (; j < this.rows; j++) {
					this.eraseLine(j);
				}
				break;
			case 1:
				this.eraseLeft(this.x, this.y);
				for j=this.y-1:-1:0
					this.eraseLine(j);
				break;
			case 2:
				for j=this.rows-1:-1:0
					this.eraseLine(j);
				break;
			case 3:
				; // no saved lines
				break;
		}
	};
	
	
	/**
	* CSI Ps K  Erase in Line (EL).
	*     Ps=0  -> Erase to Right (default).
	*     Ps=1  -> Erase to Left.
	*     Ps=2  -> Erase All.
	* CSI ? Ps K
	*   Erase in Line (DECSEL).
	*     Ps=0  -> Selective Erase to Right (default).
	*     Ps=1  -> Selective Erase to Left.
	*     Ps=2  -> Selective Erase All.
	*/
	eraseInLine=function(params) {
		switch (params[0]) {
			case 0:
				this.eraseRight(this.x, this.y);
				break;
			case 1:
				this.eraseLeft(this.x, this.y);
				break;
			case 2:
				this.eraseLine(this.y);
				break;
		}
	};
	
	
	/**
	* CSI Pm m  Character Attributes (SGR).
	*     Ps=0  -> Normal (default).
	*     Ps=1  -> Bold.
	*     Ps=4  -> Underlined.
	*     Ps=5  -> Blink (appears as Bold).
	*     Ps=7  -> Inverse.
	*     Ps=8  -> Invisible, i.e., hidden (VT300).
	*     Ps=2 2  -> Normal (neither bold nor faint).
	*     Ps=2 4  -> Not underlined.
	*     Ps=2 5  -> Steady (not blinking).
	*     Ps=2 7  -> Positive (not inverse).
	*     Ps=2 8  -> Visible, i.e., not hidden (VT300).
	*     Ps=3 0  -> Set foreground color to Black.
	*     Ps=3 1  -> Set foreground color to Red.
	*     Ps=3 2  -> Set foreground color to Green.
	*     Ps=3 3  -> Set foreground color to Yellow.
	*     Ps=3 4  -> Set foreground color to Blue.
	*     Ps=3 5  -> Set foreground color to Magenta.
	*     Ps=3 6  -> Set foreground color to Cyan.
	*     Ps=3 7  -> Set foreground color to White.
	*     Ps=3 9  -> Set foreground color to default (original).
	*     Ps=4 0  -> Set background color to Black.
	*     Ps=4 1  -> Set background color to Red.
	*     Ps=4 2  -> Set background color to Green.
	*     Ps=4 3  -> Set background color to Yellow.
	*     Ps=4 4  -> Set background color to Blue.
	*     Ps=4 5  -> Set background color to Magenta.
	*     Ps=4 6  -> Set background color to Cyan.
	*     Ps=4 7  -> Set background color to White.
	*     Ps=4 9  -> Set background color to default (original).
	*
	*   If 16-color support is compiled, the following apply.  Assume
	*   that xterm's resources are set so that the ISO color codes are
	*   the first 8 of a set of 16.  Then the aixterm colors are the
	*   bright versions of the ISO colors:
	*     Ps=9 0  -> Set foreground color to Black.
	*     Ps=9 1  -> Set foreground color to Red.
	*     Ps=9 2  -> Set foreground color to Green.
	*     Ps=9 3  -> Set foreground color to Yellow.
	*     Ps=9 4  -> Set foreground color to Blue.
	*     Ps=9 5  -> Set foreground color to Magenta.
	*     Ps=9 6  -> Set foreground color to Cyan.
	*     Ps=9 7  -> Set foreground color to White.
	*     Ps=1 0 0  -> Set background color to Black.
	*     Ps=1 0 1  -> Set background color to Red.
	*     Ps=1 0 2  -> Set background color to Green.
	*     Ps=1 0 3  -> Set background color to Yellow.
	*     Ps=1 0 4  -> Set background color to Blue.
	*     Ps=1 0 5  -> Set background color to Magenta.
	*     Ps=1 0 6  -> Set background color to Cyan.
	*     Ps=1 0 7  -> Set background color to White.
	*
	*   If xterm is compiled with the 16-color support disabled, it
	*   supports the following, from rxvt:
	*     Ps=1 0 0  -> Set foreground and background color to
	*     default.
	*
	*   If 88- or 256-color support is compiled, the following apply.
	*     Ps=3 8  ; 5  ; Ps -> Set foreground color to the second
	*     Ps.
	*     Ps=4 8  ; 5  ; Ps -> Set background color to the second
	*     Ps.
	*/
	charAttributes=function(params) {
		// Optimize a single SGR0.
		if (params.n == 1 && params[0] == 0) {
			this.curAttr=this.defAttr;
			return;
		}
	
		auto l=params.n;
		auto i=0;
		auto flags=this.curAttr >> 18;
		auto fg=(this.curAttr >> 9) & 0x1ff;
		auto bg=this.curAttr & 0x1ff;
		auto p;
	
		for (; i < l; i++) {
			p=params[i];
			if (p >= 30 && p <= 37) {
				// fg color 8
				fg=p - 30;
			} else if (p >= 40 && p <= 47) {
				// bg color 8
				bg=p - 40;
			} else if (p >= 90 && p <= 97) {
				// fg color 16
				p += 8;
				fg=p - 90;
			} else if (p >= 100 && p <= 107) {
				// bg color 16
				p += 8;
				bg=p - 100;
			} else if (p == 0) {
				// default
				flags=this.defAttr >> 18;
				fg=(this.defAttr >> 9) & 0x1ff;
				bg=this.defAttr & 0x1ff;
				// flags=0;
				// fg=0x1ff;
				// bg=0x1ff;
			} else if (p == 1) {
				// bold text
				flags |= 1;
			} else if (p == 4) {
				// underlined text
				flags |= 2;
			} else if (p == 5) {
				// blink
				flags |= 4;
			} else if (p == 7) {
				// inverse and positive
				// test with: echo -e '\e[31m\e[42mhello\e[7mworld\e[27mhi\e[m'
				flags |= 8;
			} else if (p == 8) {
				// invisible
				flags |= 16;
			} else if (p == 22) {
				// not bold
				flags &= ~1;
			} else if (p == 24) {
				// not underlined
				flags &= ~2;
			} else if (p == 25) {
				// not blink
				flags &= ~4;
			} else if (p == 27) {
				// not inverse
				flags &= ~8;
			} else if (p == 28) {
				// not invisible
				flags &= ~16;
			} else if (p == 39) {
				// reset fg
				fg=(this.defAttr >> 9) & 0x1ff;
			} else if (p == 49) {
				// reset bg
				bg=this.defAttr & 0x1ff;
			} else if (p == 38) {
				// fg color 256
				if (params[i + 1] == 2) {
					i += 2;
					fg=matchColor(
						params[i] & 0xff,
						params[i + 1] & 0xff,
						params[i + 2] & 0xff);
					if (fg == -1) fg=257;
					i += 2;
				} else if (params[i + 1] == 5) {
					i += 2;
					p=params[i] & 0xff;
					fg=p;
				}
			} else if (p == 48) {
				// bg color 256
				if (params[i + 1] == 2) {
					i += 2;
					bg=matchColor(
						params[i] & 0xff,
						params[i + 1] & 0xff,
						params[i + 2] & 0xff);
					if (bg == -1) bg=256;
					i += 2;
				} else if (params[i + 1] == 5) {
					i += 2;
					p=params[i] & 0xff;
					bg=p;
				}
			} else if (p == 100) {
				// reset fg/bg
				fg=(this.defAttr >> 9) & 0x1ff;
				bg=this.defAttr & 0x1ff;
			} else {
				//this.error('Unknown SGR attribute: %d.', p);
			}
		}
	
		this.curAttr=(flags << 18) | (fg << 9) | bg;
	};
	
	
	/**
	* CSI Ps n  Device Status Report (DSR).
	*     Ps=5  -> Status Report.  Result (``OK'') is
	*   CSI 0 n
	*     Ps=6  -> Report Cursor Position (CPR) [row;column].
	*   Result is
	*   CSI r ; c R
	* CSI ? Ps n
	*   Device Status Report (DSR, DEC-specific).
	*     Ps=6  -> Report Cursor Position (CPR) [row;column] as CSI
	*     ? r ; c R (assumes page is zero).
	*     Ps=1 5  -> Report Printer status as CSI ? 1 0  n  (ready).
	*     or CSI ? 1 1  n  (not ready).
	*     Ps=2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)
	*     or CSI ? 2 1  n  (locked).
	*     Ps=2 6  -> Report Keyboard status as
	*   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).
	*   The last two parameters apply to VT400 & up, and denote key-
	*   board ready and LK01 respectively.
	*     Ps=5 3  -> Report Locator status as
	*   CSI ? 5 3  n  Locator available, if compiled-in, or
	*   CSI ? 5 0  n  No Locator, if not.
	*/
	deviceStatus=function(params) {
		if (!this.prefix||!this.prefix.n) {
			switch (params[0]) {
				case 5:
					// status report
					this.send('\x1b[0n');
					break;
				case 6:
					// cursor position
					this.send(FormatAsText('\x1b['
							, (this.y + 1)
							, ';'
							, (this.x + 1)
							, 'R'));
					break;
			}
		} else if (this.prefix == "?") {
			// modern xterm doesnt seem to
			// respond to any of these except ?6, 6, and 5
			switch (params[0]) {
				case 6:
					// cursor position
					this.send(FormatAsText('\x1b['
							, (this.y + 1)
							, ';'
							, (this.x + 1)
							, 'R'));
					break;
				case 15:
					// no printer
					// this.send('\x1b[?11n');
					break;
				case 25:
					// dont support user defined keys
					// this.send('\x1b[?21n');
					break;
				case 26:
					// north american keyboard
					// this.send('\x1b[?27;1;0;0n');
					break;
				case 53:
					// no dec locator/mouse
					// this.send('\x1b[?50n');
					break;
			}
		}
	};
	
	
	/**
	* Additions
	*/
	
	/**
	* CSI Ps @
	* Insert Ps (Blank) Character(s) (default=1) (ICH).
	*/
	insertChars=function(params) {
		auto param, row, j;
	
		param=params.n>=1?params[0]:1;
		
		row=(this.y + this.ybase)%this.scrollback;
		j=this.x;
		param=min(max(param,1),this.cols-j)
		n_left=this.cols-j-param
		__basic_api.memmove(
			__pointer(this.lines.d+(row*this.cols+j+param)*(3*sizeof(int))),
			__pointer(this.lines.d+(row*this.cols+j)*(3*sizeof(int))),
			n_left*(3*sizeof(int)))
		this.clearWithAttr(row*this.cols+j,this.eraseAttr(),param)
	};
	
	/**
	* CSI Ps E
	* Cursor Next Line Ps Times (default=1) (CNL).
	* same as CSI Ps B ?
	*/
	cursorNextLine=function(params) {
		auto param=params[0];
		if (param < 1): param=1;
		this.y += param;
		if (this.y >= this.rows) {
			this.y=this.rows - 1;
		}
		this.x=0;
	};
	
	
	/**
	* CSI Ps F
	* Cursor Preceding Line Ps Times (default=1) (CNL).
	* reuse CSI Ps A ?
	*/
	cursorPrecedingLine=function(params) {
		auto param=params[0];
		if (param < 1): param=1;
		this.y -= param;
		if (this.y < 0): this.y=0;
		this.x=0;
	};
	
	
	/**
	* CSI Ps G
	* Cursor Character Absolute  [column] (default=[row,1]) (CHA).
	*/
	cursorCharAbsolute=function(params) {
		auto param=params[0];
		if (param < 1): param=1;
		this.x=param - 1;
	};
	
	
	/**
	* CSI Ps L
	* Insert Ps Line(s) (default=1) (IL).
	*/
	insertLines=function(params) {
		auto param, row, j;
	
		param=params[0];
		row=(this.y + this.ybase)%this.scrollback;
	
		param=min(max(param,1),this.scrollBottom+1-this.y)
		n_lines_kept=this.scrollBottom+1-this.y-param
		if n_lines_kept>0:
			this.moveRows(row+param,row,n_lines_kept)
		for i=0:param-1
			this.clearWithAttr((row+i)%this.scrollback*this.cols,this.curAttr,this.cols)
	
		// this.maxRange();
		//this.updateRange(this.y);
		//this.updateRange(this.scrollBottom);
	};
	
	
	/**
	* CSI Ps M
	* Delete Ps Line(s) (default=1) (DL).
	*/
	deleteLines=function(params) {
		auto param, row, j;
	
		param=params[0];
		row=(this.y + this.ybase)%this.scrollback;
	
		param=min(max(param,1),this.scrollBottom+1-this.y)
		n_lines_kept=this.scrollBottom+1-this.y-param
		if n_lines_kept>0:
			this.moveRows(row,row+param,n_lines_kept)
		for i=0:param-1
			this.clearWithAttr((row+n_lines_kept+i)%this.scrollback*this.cols,this.curAttr,this.cols)
	};
	
	
	/**
	* CSI Ps P
	* Delete Ps Character(s) (default=1) (DCH).
	*/
	deleteChars=function(params) {
		auto param, row, ch;
	
		param=params[0];
		row=(this.y + this.ybase)%this.scrollback;
		j=this.x;
		param=min(max(param,1),this.cols-j)
		n_left=this.cols-j-param
		__basic_api.memmove(
			__pointer(this.lines.d+(row*this.cols+j)*(3*sizeof(int))),
			__pointer(this.lines.d+(row*this.cols+j+param)*(3*sizeof(int))),
			n_left*(3*sizeof(int)))
		this.clearWithAttr(row*this.cols+j+n_left,this.eraseAttr(),param)
	};
	
	/**
	* CSI Ps X
	* Erase Ps Character(s) (default=1) (ECH).
	*/
	eraseChars=function(params) {
		auto param, row, j, ch;
	
		param=params[0];
		j=this.x;
		param=min(max(param,1),this.cols-j)
		this.clearWithAttr(row*this.cols+j,this.eraseAttr(),param)
	};
	
	/**
	* CSI Pm `  Character Position Absolute
	*   [column] (default=[row,1]) (HPA).
	*/
	charPosAbsolute=function(params) {
		auto param=params[0];
		if (param < 1) param=1;
		this.x=param - 1;
		if (this.x >= this.cols) {
			this.x=this.cols - 1;
		}
	};
	
	
	/**
	* 141 61 a * HPR -
	* Horizontal Position Relative
	* reuse CSI Ps C ?
	*/
	HPositionRelative=function(params) {
		auto param=params[0];
		if (param < 1) param=1;
		this.x += param;
		if (this.x >= this.cols) {
			this.x=this.cols - 1;
		}
	};
	
	
	/**
	* CSI Ps c  Send Device Attributes (Primary DA).
	*     Ps=0  or omitted -> request attributes from g_  The
	*     response depends on the decTerminalID resource setting.
	*     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')
	*     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')
	*     -> CSI ? 6 c  (``VT102'')
	*     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')
	*   The VT100-style response parameters do not mean anything by
	*   themselves.  VT220 parameters do, telling the host what fea-
	*   tures the terminal supports:
	*     Ps=1  -> 132-columns.
	*     Ps=2  -> Printer.
	*     Ps=6  -> Selective erase.
	*     Ps=8  -> User-defined keys.
	*     Ps=9  -> National replacement character sets.
	*     Ps=1 5  -> Technical characters.
	*     Ps=2 2  -> ANSI color, e.g., VT525.
	*     Ps=2 9  -> ANSI text locator (i.e., DEC Locator mode).
	* CSI > Ps c
	*   Send Device Attributes (Secondary DA).
	*     Ps=0  or omitted -> request the terminal's identification
	*     code.  The response depends on the decTerminalID resource set-
	*     ting.  It should apply only to VT220 and up, but xterm extends
	*     this to VT100.
	*     -> CSI  > Pp ; Pv ; Pc c
	*   where Pp denotes the terminal type
	*     Pp=0  -> ``VT100''.
	*     Pp=1  -> ``VT220''.
	*   and Pv is the firmware version (for xterm, this was originally
	*   the XFree86 patch number, starting with 95).  In a DEC termi-
	*   nal, Pc indicates the ROM cartridge registration number and is
	*   always zero.
	* More information:
	*   xterm/charproc.c - line 2012, for more information.
	*   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)
	*/
	sendDeviceAttributes=function(params) {
		if (params[0] > 0): return;
	
		if (!this.prefix||!this.prefix.n) {
			if (this.termName==('xterm')
			|| this.termName==('rxvt-unicode')
			|| this.termName==('screen')) {
				this.send('\x1b[?1;2c');
			} else if (this.termName==('linux')) {
				this.send('\x1b[?6c');
			}
		} else if (this.prefix == ">") {
			// xterm and urxvt
			// seem to spit this
			// out around ~370 times (?).
			if (this.termName==('xterm')) {
				this.send('\x1b[>0;276;0c');
			} else if (this.termName==('rxvt-unicode')) {
				this.send('\x1b[>85;95;0c');
			} else if (this.termName==('linux')) {
				// not supported by linux console.
				// linux console echoes parameters.
				this.send(FormatAsText(params[0],'c'));
			} else if (this.termName==('screen')) {
				this.send('\x1b[>83;40003;0c');
			}
		}
	};
	
	
	/**
	* CSI Pm d
	* Line Position Absolute  [row] (default=[1,column]) (VPA).
	*/
	linePosAbsolute=function(params) {
		auto param=params[0];
		if (param < 1): param=1;
		this.y=param - 1;
		if (this.y >= this.rows) {
			this.y=this.rows - 1;
		}
		//Writeln('linePosAbsolute ',params,' ',this.y,' ',this.x)
	};
	
	
	/**
	* 145 65 e * VPR - Vertical Position Relative
	* reuse CSI Ps B ?
	*/
	VPositionRelative=function(params) {
		auto param=params[0];
		if (param < 1): param=1;
		this.y += param;
		if (this.y >= this.rows) {
			this.y=this.rows - 1;
		}
	};
	
	
	/**
	* CSI Ps ; Ps f
	*   Horizontal and Vertical Position [row;column] (default =
	*   [1,1]) (HVP).
	*/
	HVPosition=function(params) {
		this.y=max(params.n>=1?params[0]:1,1) - 1;
		if (this.y >= this.rows) {
			this.y=this.rows - 1;
		}
	
		this.x=max(params.n>=2?params[1]:1,1) - 1;
		if (this.x >= this.cols) {
			this.x=this.cols - 1;
		}
	};
	
	
	/**
	* CSI Pm h  Set Mode (SM).
	*     Ps=2  -> Keyboard Action Mode (AM).
	*     Ps=4  -> Insert Mode (IRM).
	*     Ps=1 2  -> Send/receive (SRM).
	*     Ps=2 0  -> Automatic Newline (LNM).
	* CSI ? Pm h
	*   DEC Private Mode Set (DECSET).
	*     Ps=1  -> Application Cursor Keys (DECCKM).
	*     Ps=2  -> Designate USASCII for character sets G0-G3
	*     (DECANM), and set VT100 mode.
	*     Ps=3  -> 132 Column Mode (DECCOLM).
	*     Ps=4  -> Smooth (Slow) Scroll (DECSCLM).
	*     Ps=5  -> Reverse Video (DECSCNM).
	*     Ps=6  -> Origin Mode (DECOM).
	*     Ps=7  -> Wraparound Mode (DECAWM).
	*     Ps=8  -> Auto-repeat Keys (DECARM).
	*     Ps=9  -> Send Mouse X & Y on button press.  See the sec-
	*     tion Mouse Tracking.
	*     Ps=1 0  -> Show toolbar (rxvt).
	*     Ps=1 2  -> Start Blinking Cursor (att610).
	*     Ps=1 8  -> Print form feed (DECPFF).
	*     Ps=1 9  -> Set print extent to full screen (DECPEX).
	*     Ps=2 5  -> Show Cursor (DECTCEM).
	*     Ps=3 0  -> Show scrollbar (rxvt).
	*     Ps=3 5  -> Enable font-shifting functions (rxvt).
	*     Ps=3 8  -> Enter Tektronix Mode (DECTEK).
	*     Ps=4 0  -> Allow 80 -> 132 Mode.
	*     Ps=4 1  -> more(1) fix (see curses resource).
	*     Ps=4 2  -> Enable Nation Replacement Character sets (DECN-
	*     RCM).
	*     Ps=4 4  -> Turn On Margin Bell.
	*     Ps=4 5  -> Reverse-wraparound Mode.
	*     Ps=4 6  -> Start Logging.  This is normally disabled by a
	*     compile-time option.
	*     Ps=4 7  -> Use Alternate Screen Buffer.  (This may be dis-
	*     abled by the titeInhibit resource).
	*     Ps=6 6  -> Application keypad (DECNKM).
	*     Ps=6 7  -> Backarrow key sends backspace (DECBKM).
	*     Ps=1 0 0 0  -> Send Mouse X & Y on button press and
	*     release.  See the section Mouse Tracking.
	*     Ps=1 0 0 1  -> Use Hilite Mouse Tracking.
	*     Ps=1 0 0 2  -> Use Cell Motion Mouse Tracking.
	*     Ps=1 0 0 3  -> Use All Motion Mouse Tracking.
	*     Ps=1 0 0 4  -> Send FocusIn/FocusOut events.
	*     Ps=1 0 0 5  -> Enable Extended Mouse Mode.
	*     Ps=1 0 1 0  -> Scroll to bottom on tty output (rxvt).
	*     Ps=1 0 1 1  -> Scroll to bottom on key press (rxvt).
	*     Ps=1 0 3 4  -> Interpret "meta" key, sets eighth bit.
	*     (enables the eightBitInput resource).
	*     Ps=1 0 3 5  -> Enable special modifiers for Alt and Num-
	*     Lock keys.  (This enables the numLock resource).
	*     Ps=1 0 3 6  -> Send ESC   when Meta modifies a key.  (This
	*     enables the metaSendsEscape resource).
	*     Ps=1 0 3 7  -> Send DEL from the editing-keypad Delete
	*     key.
	*     Ps=1 0 3 9  -> Send ESC  when Alt modifies a key.  (This
	*     enables the altSendsEscape resource).
	*     Ps=1 0 4 0  -> Keep selection even if not highlighted.
	*     (This enables the keepSelection resource).
	*     Ps=1 0 4 1  -> Use the CLIPBOARD selection.  (This enables
	*     the selectToClipboard resource).
	*     Ps=1 0 4 2  -> Enable Urgency window manager hint when
	*     Control-G is received.  (This enables the bellIsUrgent
	*     resource).
	*     Ps=1 0 4 3  -> Enable raising of the window when Control-G
	*     is received.  (enables the popOnBell resource).
	*     Ps=1 0 4 7  -> Use Alternate Screen Buffer.  (This may be
	*     disabled by the titeInhibit resource).
	*     Ps=1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-
	*     abled by the titeInhibit resource).
	*     Ps=1 0 4 9  -> Save cursor as in DECSC and use Alternate
	*     Screen Buffer, clearing it first.  (This may be disabled by
	*     the titeInhibit resource).  This combines the effects of the 1
	*     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based
	*     applications rather than the 4 7  mode.
	*     Ps=1 0 5 0  -> Set terminfo/termcap function-key mode.
	*     Ps=1 0 5 1  -> Set Sun function-key mode.
	*     Ps=1 0 5 2  -> Set HP function-key mode.
	*     Ps=1 0 5 3  -> Set SCO function-key mode.
	*     Ps=1 0 6 0  -> Set legacy keyboard emulation (X11R6).
	*     Ps=1 0 6 1  -> Set VT220 keyboard emulation.
	*     Ps=2 0 0 4  -> Set bracketed paste mode.
	* Modes:
	*   http: *vt100.net/docs/vt220-rm/chapter4.html
	*/
	setMode=function(params) {
		if (typeof(params) == int[]) {
			auto l=params.n, i=0;
	
			for (; i < l; i++) {
				this.setMode(params[i]);
			}
	
			return;
		}else{
	
			if (!this.prefix||!this.prefix.n) {
				switch (params) {
					case 4:
						this.insertMode=true;
						break;
					case 20:
						//this.convertEol=true;
						break;
				}
			} else if (this.prefix == "?") {
				switch (params) {
					case 1:
						this.applicationCursor=true;
						break;
					case 2:
						this.setgCharset(0, g_charsets.US);
						this.setgCharset(1, g_charsets.US);
						this.setgCharset(2, g_charsets.US);
						this.setgCharset(3, g_charsets.US);
						// set VT100 mode here
						break;
					case 3: // 132 col mode
						this.savedCols=this.cols;
						this.resize(132, this.rows);
						break;
					case 6:
						this.originMode=true;
						break;
					case 7:
						this.wraparoundMode=true;
						break;
					case 12:
						// this.cursorBlink=true;
						break;
					case 66:
						//this.log('Serial port requested application keypad.');
						this.applicationKeypad=true;
						//this.viewport.syncScrollArea();
						break;
					case 9: // X10 Mouse
						// no release, no motion, no wheel, no modifiers.
					case 1000: // vt200 mouse
						// no motion.
						// no modifiers, except control on the wheel.
					case 1002: // button event mouse
					case 1003: // any event mouse
						// any event - sends motion events,
						// even if there is no button held down.
						//this.x10Mouse=(params == 9);
						//this.vt200Mouse=(params == 1000);
						//this.normalMouse=(params > 1000);
						//this.mouseEvents=true;
						//this.element.style.cursor='default';
						//this.log('Binding to mouse events.');
						break;
					case 1004: // send focusin/focusout events
						// focusin: ^[[I
						// focusout: ^[[O
						this.sendFocus=true;
						break;
					case 1005: // utf8 ext mode mouse
						//this.utfMouse=true;
						// for wide terminals
						// simply encodes large values as utf8 characters
						break;
					case 1006: // sgr ext mode mouse
						//this.sgrMouse=true;
						// for wide terminals
						// does not add 32 to fields
						// press: ^[[<b;x;yM
						// release: ^[[<b;x;ym
						break;
					case 1015: // urxvt ext mode mouse
						//this.urxvtMouse=true;
						// for wide terminals
						// numbers for fields
						// press: ^[[b;x;yM
						// motion: ^[[b;x;yT
						break;
					case 25: // show cursor
						this.cursorHidden=false;
						break;
					case 47,1047,1049: // alt screen buffer
						if (!this.has_normal) {
							auto normal={
								lines: this.lines,
								line_end_states: this.line_end_states,
								ybase: this.ybase,
								ydisp: this.ydisp,
								n_valid_lines: this.n_valid_lines,
								x: this.x,
								y: this.y,
								scrollTop: this.scrollTop,
								scrollBottom: this.scrollBottom,
								tabs: this.tabs,
								// XXX save charset(s) here?
								// charset: this.charset,
								// glevel: this.glevel,
								// charsets: this.charsets
							};
							this.reset();
							this.normal=normal;
							this.has_normal=1
						}
						break;
				}
			}
		}
	};
	
	/**
	* CSI Pm l  Reset Mode (RM).
	*     Ps=2  -> Keyboard Action Mode (AM).
	*     Ps=4  -> Replace Mode (IRM).
	*     Ps=1 2  -> Send/receive (SRM).
	*     Ps=2 0  -> Normal Linefeed (LNM).
	* CSI ? Pm l
	*   DEC Private Mode Reset (DECRST).
	*     Ps=1  -> Normal Cursor Keys (DECCKM).
	*     Ps=2  -> Designate VT52 mode (DECANM).
	*     Ps=3  -> 80 Column Mode (DECCOLM).
	*     Ps=4  -> Jump (Fast) Scroll (DECSCLM).
	*     Ps=5  -> Normal Video (DECSCNM).
	*     Ps=6  -> Normal Cursor Mode (DECOM).
	*     Ps=7  -> No Wraparound Mode (DECAWM).
	*     Ps=8  -> No Auto-repeat Keys (DECARM).
	*     Ps=9  -> Don't send Mouse X & Y on button press.
	*     Ps=1 0  -> Hide toolbar (rxvt).
	*     Ps=1 2  -> Stop Blinking Cursor (att610).
	*     Ps=1 8  -> Don't print form feed (DECPFF).
	*     Ps=1 9  -> Limit print to scrolling region (DECPEX).
	*     Ps=2 5  -> Hide Cursor (DECTCEM).
	*     Ps=3 0  -> Don't show scrollbar (rxvt).
	*     Ps=3 5  -> Disable font-shifting functions (rxvt).
	*     Ps=4 0  -> Disallow 80 -> 132 Mode.
	*     Ps=4 1  -> No more(1) fix (see curses resource).
	*     Ps=4 2  -> Disable Nation Replacement Character sets (DEC-
	*     NRCM).
	*     Ps=4 4  -> Turn Off Margin Bell.
	*     Ps=4 5  -> No Reverse-wraparound Mode.
	*     Ps=4 6  -> Stop Logging.  (This is normally disabled by a
	*     compile-time option).
	*     Ps=4 7  -> Use Normal Screen Buffer.
	*     Ps=6 6  -> Numeric keypad (DECNKM).
	*     Ps=6 7  -> Backarrow key sends delete (DECBKM).
	*     Ps=1 0 0 0  -> Don't send Mouse X & Y on button press and
	*     release.  See the section Mouse Tracking.
	*     Ps=1 0 0 1  -> Don't use Hilite Mouse Tracking.
	*     Ps=1 0 0 2  -> Don't use Cell Motion Mouse Tracking.
	*     Ps=1 0 0 3  -> Don't use All Motion Mouse Tracking.
	*     Ps=1 0 0 4  -> Don't send FocusIn/FocusOut events.
	*     Ps=1 0 0 5  -> Disable Extended Mouse Mode.
	*     Ps=1 0 1 0  -> Don't scroll to bottom on tty output
	*     (rxvt).
	*     Ps=1 0 1 1  -> Don't scroll to bottom on key press (rxvt).
	*     Ps=1 0 3 4  -> Don't interpret "meta" key.  (This disables
	*     the eightBitInput resource).
	*     Ps=1 0 3 5  -> Disable special modifiers for Alt and Num-
	*     Lock keys.  (This disables the numLock resource).
	*     Ps=1 0 3 6  -> Don't send ESC  when Meta modifies a key.
	*     (This disables the metaSendsEscape resource).
	*     Ps=1 0 3 7  -> Send VT220 Remove from the editing-keypad
	*     Delete key.
	*     Ps=1 0 3 9  -> Don't send ESC  when Alt modifies a key.
	*     (This disables the altSendsEscape resource).
	*     Ps=1 0 4 0  -> Do not keep selection when not highlighted.
	*     (This disables the keepSelection resource).
	*     Ps=1 0 4 1  -> Use the PRIMARY selection.  (This disables
	*     the selectToClipboard resource).
	*     Ps=1 0 4 2  -> Disable Urgency window manager hint when
	*     Control-G is received.  (This disables the bellIsUrgent
	*     resource).
	*     Ps=1 0 4 3  -> Disable raising of the window when Control-
	*     G is received.  (This disables the popOnBell resource).
	*     Ps=1 0 4 7  -> Use Normal Screen Buffer, clearing screen
	*     first if in the Alternate Screen.  (This may be disabled by
	*     the titeInhibit resource).
	*     Ps=1 0 4 8  -> Restore cursor as in DECRC.  (This may be
	*     disabled by the titeInhibit resource).
	*     Ps=1 0 4 9  -> Use Normal Screen Buffer and restore cursor
	*     as in DECRC.  (This may be disabled by the titeInhibit
	*     resource).  This combines the effects of the 1 0 4 7  and 1 0
	*     4 8  modes.  Use this with terminfo-based applications rather
	*     than the 4 7  mode.
	*     Ps=1 0 5 0  -> Reset terminfo/termcap function-key mode.
	*     Ps=1 0 5 1  -> Reset Sun function-key mode.
	*     Ps=1 0 5 2  -> Reset HP function-key mode.
	*     Ps=1 0 5 3  -> Reset SCO function-key mode.
	*     Ps=1 0 6 0  -> Reset legacy keyboard emulation (X11R6).
	*     Ps=1 0 6 1  -> Reset keyboard emulation to Sun/PC style.
	*     Ps=2 0 0 4  -> Reset bracketed paste mode.
	*/
	resetMode=function(params) {
		if (typeof(params) == int[]) {
			auto l=params.n, i=0;
	
			for (; i < l; i++) {
				this.resetMode(params[i]);
			}
	
			return;
		}else{
	
			if (!this.prefix||!this.prefix.n) {
				switch (params) {
					case 4:
						this.insertMode=false;
						break;
					case 20:
						//this.convertEol=false;
						break;
				}
			} else if (this.prefix == "?") {
				switch (params) {
					case 1:
						this.applicationCursor=false;
						break;
					case 3:
						if (this.cols == 132 && this.savedCols) {
							this.resize(this.savedCols, this.rows);
						}
						this.savedCols=0;
						break;
					case 6:
						this.originMode=false;
						break;
					case 7:
						this.wraparoundMode=false;
						break;
					case 12:
						// this.cursorBlink=false;
						break;
					case 66:
						//this.log('Switching back to normal keypad.');
						this.applicationKeypad=false;
						//this.viewport.syncScrollArea();
						break;
					case 9: // X10 Mouse
					case 1000: // vt200 mouse
					case 1002: // button event mouse
					case 1003: // any event mouse
						//this.x10Mouse=false;
						//this.vt200Mouse=false;
						//this.normalMouse=false;
						//this.mouseEvents=false;
						//this.element.style.cursor='';
						break;
					case 1004: // send focusin/focusout events
						this.sendFocus=false;
						break;
					case 1005: // utf8 ext mode mouse
						//this.utfMouse=false;
						break;
					case 1006: // sgr ext mode mouse
						//this.sgrMouse=false;
						break;
					case 1015: // urxvt ext mode mouse
						//this.urxvtMouse=false;
						break;
					case 25: // hide cursor
						this.cursorHidden=true;
						break;
					case 47,1047,1049: // normal screen buffer - clearing it first
						if (this.has_normal) {
							this.lines=this.normal.lines;
							this.line_end_states=this.normal.line_end_states;
							this.ybase=this.normal.ybase;
							this.ydisp=this.normal.ydisp;
							this.n_valid_lines=this.normal.n_valid_lines
							this.x=this.normal.x;
							this.y=this.normal.y;
							this.scrollTop=this.normal.scrollTop;
							this.scrollBottom=this.normal.scrollBottom;
							this.tabs=this.normal.tabs;
							this.has_normal=0
							// if (params == 1049) {
							//   this.x=this.savedX;
							//   this.y=this.savedY;
							// }
							//this.refresh(0, this.rows - 1);
						}
						break;
				}
			}
		}
	};
	
	
	/**
	* CSI Ps ; Ps r
	*   Set Scrolling Region [top;bottom] (default=full size of win-
	*   dow) (DECSTBM).
	* CSI ? Pm r
	*/
	setScrollRegion=function(params) {
		if this.prefix.n: return;
		this.scrollTop=min(max((params.n>=1?params[0]:1) - 1,0),this.rows-1);
		this.scrollBottom=min(max((params.n>=2?params[1]:this.rows) - 1,this.scrollTop),this.rows-1);
		this.x=0;
		this.y=0;
	};
	
	/**
	* CSI s
	*   Save cursor (ANSI.SYS).
	*/
	saveCursor=function() {
		this.savedX=this.x;
		this.savedY=this.y;
	};
	
	
	/**
	* CSI u
	*   Restore cursor (ANSI.SYS).
	*/
	restoreCursor=function() {
		this.x=this.savedX;
		this.y=this.savedY;
	};
	
	
	/**
	* Lesser Used
	*/
	
	/**
	* CSI Ps I
	*   Cursor Forward Tabulation Ps tab stops (default=1) (CHT).
	*/
	cursorForwardTab=function(int[] params) {
		auto param=(params.n>=1?params[0]:1);
		for i=0:param-1
			this.x=this.nextStop(this.x);
	};
	
	
	/**
	* CSI Ps S  Scroll up Ps lines (default=1) (SU).
	*/
	scrollUp=function(params) {
		auto param=(params.n>=1?params[0]:1);
		param=min(max(param,1),n_lines_area)
		auto n_lines_area=this.scrollBottom+1-this.scrollTop
		auto n_lines_kept=n_lines_area-param
		this.moveRows(this.ybase+this.scrollTop,this.ybase+this.scrollTop+param,n_lines_kept)
		row=(this.ybase + this.scrollTop+n_lines_kept)%this.scrollback;
		this.clearWithAttr(row*this.cols,this.defAttr,param*this.cols)
	};
	
	
	/**
	* CSI Ps T  Scroll down Ps lines (default=1) (SD).
	*/
	scrollDown=function(param0) {
		n_lines_area=this.scrollBottom+1-this.scrollTop
		param=min(max(param0,1),n_lines_area)
		n_lines_kept=n_lines_area-param
		this.moveRows(this.ybase+this.scrollTop+param,this.ybase+this.scrollTop,n_lines_kept)
		row=(this.ybase + this.scrollTop)%this.scrollback;
		this.clearWithAttr(row*this.cols,this.defAttr,param*this.cols)
	};
	
	
	/**
	* CSI Ps ; Ps ; Ps ; Ps ; Ps T
	*   Initiate highlight mouse tracking.  Parameters are
	*   [func;startx;starty;firstrow;lastrow].  See the section Mouse
	*   Tracking.
	*/
	initMouseTracking=function(params) {
		// Relevant: DECSET 1001
	};
	
	
	/**
	* CSI > Ps; Ps T
	*   Reset one or more features of the title modes to the default
	*   value.  Normally, "reset" disables the feature.  It is possi-
	*   ble to disable the ability to reset features by compiling a
	*   different default for the title modes into xterm.
	*     Ps=0  -> Do not set window/icon labels using hexadecimal.
	*     Ps=1  -> Do not query window/icon labels using hexadeci-
	*     mal.
	*     Ps=2  -> Do not set window/icon labels using UTF-8.
	*     Ps=3  -> Do not query window/icon labels using UTF-8.
	*   (See discussion of "Title Modes").
	*/
	resetTitleModes=function(params) {
		;
	};
	
	
	/**
	* CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default=1) (CBT).
	*/
	cursorBackwardTab=inline(int[] params) {
		auto param=(params.n>=1?params[0]:1);
		for i=0:param-1
			this.x=this.prevStop(this.x);
	};
	
	
	/**
	* CSI Ps b  Repeat the preceding graphic character Ps times (REP).
	*/
	repeatPrecedingCharacter=function(params) {
		auto param=params.n>=1?params[0]:1
		
		row=(this.y + this.ybase)%this.scrollback;
		this.requestLines(row+1)
		j=this.x;
		param=min(max(param,1),this.cols-j)
		pchar=row*this.cols+j
		if this.x-1>0:
			chvalue=int3(this.lines[pchar*3-3],this.lines[pchar*3-2],this.lines[pchar*3-1])
		else
			chvalue=int3(this.defAttr,32,1)
		for i=0:param-1
			this.lines[pchar*3+0]=chvalue.x
			this.lines[pchar*3+1]=chvalue.y
			this.lines[pchar*3+2]=chvalue.z
			pchar++
			this.x++
		if this.x>=this.cols:
			this.x=this.cols-1
	};
	
	
	/**
	* CSI Ps g  Tab Clear (TBC).
	*     Ps=0  -> Clear Current Column (default).
	*     Ps=3  -> Clear All.
	* Potentially:
	*   Ps=2  -> Clear Stops on Line.
	*   http://vt100.net/annarbor/aaa-ug/section6.html
	*/
	tabClear=function(params) {
		auto param=params[0];
		if (param <= 0) {
			this.tabs[this.x]=0;
		} else if (param == 3) {
			__basic_api.memset(__pointer(this.tabs.d),0,this.tabs.n);
		}
	};
	
	
	/**
	* CSI Pm i  Media Copy (MC).
	*     Ps=0  -> Print screen (default).
	*     Ps=4  -> Turn off printer controller mode.
	*     Ps=5  -> Turn on printer controller mode.
	* CSI ? Pm i
	*   Media Copy (MC, DEC-specific).
	*     Ps=1  -> Print line containing cursor.
	*     Ps=4  -> Turn off autoprint mode.
	*     Ps=5  -> Turn on autoprint mode.
	*     Ps=1  0  -> Print composed display, ignores DECPEX.
	*     Ps=1  1  -> Print all pages.
	*/
	mediaCopy=function(params) {
		;
	};
	
	
	/**
	* CSI > Ps; Ps m
	*   Set or reset resource-values used by xterm to decide whether
	*   to construct escape sequences holding information about the
	*   modifiers pressed with a given key.  The first parameter iden-
	*   tifies the resource to set/reset.  The second parameter is the
	*   value to assign to the resource.  If the second parameter is
	*   omitted, the resource is reset to its initial value.
	*     Ps=1  -> modifyCursorKeys.
	*     Ps=2  -> modifyFunctionKeys.
	*     Ps=4  -> modifyOtherKeys.
	*   If no parameters are given, all resources are reset to their
	*   initial values.
	*/
	setResources=function(params) {
		;
	};
	
	
	/**
	* CSI > Ps n
	*   Disable modifiers which may be enabled via the CSI > Ps; Ps m
	*   sequence.  This corresponds to a resource value of "-1", which
	*   cannot be set with the other sequence.  The parameter identi-
	*   fies the resource to be disabled:
	*     Ps=1  -> modifyCursorKeys.
	*     Ps=2  -> modifyFunctionKeys.
	*     Ps=4  -> modifyOtherKeys.
	*   If the parameter is omitted, modifyFunctionKeys is disabled.
	*   When modifyFunctionKeys is disabled, xterm uses the modifier
	*   keys to make an extended sequence of functions rather than
	*   adding a parameter to each function key to denote the modi-
	*   fiers.
	*/
	disableModifiers=function(params) {
		;
	};
	
	
	/**
	* CSI > Ps p
	*   Set resource value pointerMode.  This is used by xterm to
	*   decide whether to hide the pointer cursor as the user types.
	*   Valid values for the parameter:
	*     Ps=0  -> never hide the pointer.
	*     Ps=1  -> hide if the mouse tracking mode is not enabled.
	*     Ps=2  -> always hide the pointer.  If no parameter is
	*     given, xterm uses the default, which is 1 .
	*/
	setPointerMode=function(params) {
		;
	};
	
	
	/**
	* CSI ! p   Soft terminal reset (DECSTR).
	* http://vt100.net/docs/vt220-rm/table4-10.html
	*/
	softReset=function(params) {
		this.cursorHidden=false;
		this.insertMode=false;
		this.originMode=false;
		this.wraparoundMode=false; // autowrap
		this.applicationKeypad=false; // ?
		//this.viewport.syncScrollArea();
		this.applicationCursor=false;
		this.scrollTop=0;
		this.scrollBottom=this.rows - 1;
		this.curAttr=this.defAttr;
		this.x=0;
		this.y=0; // ?
		this.charset=int[int].NULL;
		this.glevel=0; // ??
		this.charsets=new int[int][int]; // ??
	};
	
	
	/**
	* CSI Ps$ p
	*   Request ANSI mode (DECRQM).  For VT300 and up, reply is
	*     CSI Ps; Pm$ y
	*   where Ps is the mode number as in RM, and Pm is the mode
	*   value:
	*     0 - not recognized
	*     1 - set
	*     2 - reset
	*     3 - permanently set
	*     4 - permanently reset
	*/
	requestAnsiMode=function(params) {
		;
	};
	
	
	/**
	* CSI ? Ps$ p
	*   Request DEC private mode (DECRQM).  For VT300 and up, reply is
	*     CSI ? Ps; Pm$ p
	*   where Ps is the mode number as in DECSET, Pm is the mode value
	*   as in the ANSI DECRQM.
	*/
	requestPrivateMode=function(params) {
		;
	};
	
	
	/**
	* CSI Ps ; Ps " p
	*   Set conformance level (DECSCL).  Valid values for the first
	*   parameter:
	*     Ps=6 1  -> VT100.
	*     Ps=6 2  -> VT200.
	*     Ps=6 3  -> VT300.
	*   Valid values for the second parameter:
	*     Ps=0  -> 8-bit controls.
	*     Ps=1  -> 7-bit controls (always set for VT100).
	*     Ps=2  -> 8-bit controls.
	*/
	setConformanceLevel=function(params) {
		;
	};
	
	
	/**
	* CSI Ps q  Load LEDs (DECLL).
	*     Ps=0  -> Clear all LEDS (default).
	*     Ps=1  -> Light Num Lock.
	*     Ps=2  -> Light Caps Lock.
	*     Ps=3  -> Light Scroll Lock.
	*     Ps=2  1  -> Extinguish Num Lock.
	*     Ps=2  2  -> Extinguish Caps Lock.
	*     Ps=2  3  -> Extinguish Scroll Lock.
	*/
	loadLEDs=function(params) {
		;
	};
	
	
	/**
	* CSI Ps SP q
	*   Set cursor style (DECSCUSR, VT520).
	*     Ps=0  -> blinking block.
	*     Ps=1  -> blinking block (default).
	*     Ps=2  -> steady block.
	*     Ps=3  -> blinking underline.
	*     Ps=4  -> steady underline.
	*/
	setCursorStyle=function(params) {
		;
	};
	
	
	/**
	* CSI Ps " q
	*   Select character protection attribute (DECSCA).  Valid values
	*   for the parameter:
	*     Ps=0  -> DECSED and DECSEL can erase (default).
	*     Ps=1  -> DECSED and DECSEL cannot erase.
	*     Ps=2  -> DECSED and DECSEL can erase.
	*/
	setCharProtectionAttr=function(params) {
		;
	};
	
	
	/**
	* CSI ? Pm r
	*   Restore DEC Private Mode Values.  The value of Ps previously
	*   saved is restored.  Ps values are the same as for DECSET.
	*/
	restorePrivateValues=function(params) {
		;
	};
	
	
	/**
	* CSI Pt; Pl; Pb; Pr; Ps$ r
	*   Change Attributes in Rectangular Area (DECCARA), VT400 and up.
	*     Pt; Pl; Pb; Pr denotes the rectangle.
	*     Ps denotes the SGR attributes to change: 0, 1, 4, 5, 7.
	* NOTE: xterm doesn't enable this code by default.
	*/
	//setAttrInRectangle=function(params) {
	//	auto t=params[0], l=params[1], b=params[2], r=params[3], attr=params[4];
	//	auto line, i;
	
	//	for (; t < b + 1; t++) {
	//		line=this.lines.get(this.ybase + t);
	//		for (i=l; i < r; i++) {
	//			line[i]=[attr, line[i][1]];
	//		}
	//	}
	
	//	// this.maxRange();
	//	//this.updateRange(params[0]);
	//	//this.updateRange(params[2]);
	//};
	
	
	/**
	* CSI Pc; Pt; Pl; Pb; Pr$ x
	*   Fill Rectangular Area (DECFRA), VT420 and up.
	*     Pc is the character to use.
	*     Pt; Pl; Pb; Pr denotes the rectangle.
	* NOTE: xterm doesn't enable this code by default.
	*/
	//fillRectangle=function(params) {
	//	auto ch=params[0], t=params[1], l=params[2], b=params[3], r=params[4];
	
	//	auto line, i;
	
	//	for (; t < b + 1; t++) {
	//		line=this.lines.get(this.ybase + t);
	//		for (i=l; i < r; i++) {
	//			line[i]=[line[i][0], String_fromCharCode(ch)];
	//		}
	//	}
	
	//	// this.maxRange();
	//	//this.updateRange(params[1]);
	//	//this.updateRange(params[3]);
	//};
	
	
	/**
	* CSI Ps ; Pu ' z
	*   Enable Locator Reporting (DECELR).
	*   Valid values for the first parameter:
	*     Ps=0  -> Locator disabled (default).
	*     Ps=1  -> Locator enabled.
	*     Ps=2  -> Locator enabled for one report, then disabled.
	*   The second parameter specifies the coordinate unit for locator
	*   reports.
	*   Valid values for the second parameter:
	*     Pu=0  <- or omitted -> default to character cells.
	*     Pu=1  <- device physical pixels.
	*     Pu=2  <- character cells.
	*/
	enableLocatorReporting=function(params) {
		//auto val=params[0] > 0;
		//this.mouseEvents=val;
		//this.decLocator=val;
	};
	
	
	/**
	* CSI Pt; Pl; Pb; Pr$ z
	*   Erase Rectangular Area (DECERA), VT400 and up.
	*     Pt; Pl; Pb; Pr denotes the rectangle.
	* NOTE: xterm doesn't enable this code by default.
	*/
	//eraseRectangle=function(params) {
	//	auto t=params[0], l=params[1], b=params[2], r=params[3];
	//	auto line, i, ch;
	
	//	ch=[this.eraseAttr(), ' ', 1]; // xterm?
	
	//	for (; t < b + 1; t++) {
	//		line=this.lines.get(this.ybase + t);
	//		for (i=l; i < r; i++) {
	//			line[i]=ch;
	//		}
	//	}
	
	//	// this.maxRange();
	//	//this.updateRange(params[0]);
	//	//this.updateRange(params[2]);
	//};
	
	
	/**
	* CSI P m SP }
	* Insert P s Column(s) (default=1) (DECIC), VT420 and up.
	* NOTE: xterm doesn't enable this code by default.
	*/
	//insertColumns=function() {
	//	auto param=params[0], l=this.ybase + this.rows, ch=[this.eraseAttr(), ' ', 1], i;
	
	//	while (param--) {
	//		for (i=this.ybase; i < l; i++) {
	//			this.lines.get(i).splice(this.x + 1, 0, ch);
	//			this.lines.get(i).pop();
	//		}
	//	}
	
	//	//this.maxRange();
	//};
	
	
	/**
	* CSI P m SP ~
	* Delete P s Column(s) (default=1) (DECDC), VT420 and up
	* NOTE: xterm doesn't enable this code by default.
	*/
	//deleteColumns=function() {
	//	auto param=params[0], l=this.ybase + this.rows, ch=[this.eraseAttr(), ' ', 1], i;
	
	//	while (param--) {
	//		for (i=this.ybase; i < l; i++) {
	//			this.lines.get(i).splice(this.x, 1);
	//			this.lines.get(i).push(ch);
	//		}
	//	}
	
	//	//this.maxRange();
	//};
	download=function(string fn_local,string fn_remote){
		if this.download_buf:return 0
		fn_bash=fn_remote.Replace(["'","'\\''"])
		this.download_buf=new string
		this.download_size=-1LL
		this.download_written_size=0LL
		this.download_file=System.IO.CreateFile(fn_local)
		this.send("ONLCR=`stty|grep onlcr`;stty -onlcr;wc -c '"+fn_bash+"'|cut -f 1 -d ' ';cat '"+fn_bash+"';stty $ONLCR;\r")
		return 1
	}
	downloadWrite=function(string s){
		if !this.writable:return
		this.download_buf.push(s)
		if this.download_size<0LL:
			//try to parse the header
			pnewline=this.download_buf.IndexOf('\n')
			if pnewline>=0:
				sline_header=this.download_buf[pnewline+1:]
				pnewline2=sline_header.IndexOf('\n')
				if pnewline2>=0:
					this.download_size=sline_header[:pnewline2-1].as(i64)
					//Writeln('>>> ',sline_header[:pnewline2-1],' ',this.download_size)
					if this.download_size<0LL:
						this.download_size=0LL
					//write the command itself
					this.write(this.download_buf[:pnewline-1])
					this.write("\r\n")
					this.download_buf=new(this.download_buf[iptr(pnewline+1+pnewline2+1):])
		if this.download_size<0LL:
			//need a header
			return 0
		n_remaining=this.download_size-this.download_written_size
		if i64(this.download_buf.n)>=n_remaining:
			//write the remaining stuff
			//Writeln(this.download_written_size,' ',this.download_size,' ',this.download_buf.n)
			this.write("\rDownload completed\r\n")
			this.write(this.download_buf[iptr(n_remaining):])
			this.download_file.Write(this.download_buf[:n_remaining-1])
			this.download_file.Close()
			this.download_file=System.IO.CFile.NULL
			this.download_buf=string.NULL
			if this.input_during_download:
				s_input=this.input_during_download
				this.input_during_download=string.NULL
				this.send(s_input)
			return 1
		this.write(FormatAsText('\r',formatNumber(float(this.download_written_size+i64(this.download_buf.n))/float(this.download_size)*100.f,{frac:1}),'%'))
		if this.download_buf.n>=1048576L:
			//need to flush the result every so often, don't buffer too much
			this.download_written_size+=i64(this.download_buf.n)
			this.download_file.Write(this.download_buf)
			this.download_buf.n=0
		return 0
	}
	cancelDownload=function(){
		n_remaining=iptr(min(this.download_size-this.download_written_size,i64(this.download_buf.n)))
		this.write("\rDownload canceled\r\n")
		this.download_file.Write(this.download_buf[:n_remaining-1])
		this.download_file.Close()
		this.download_file=System.IO.CFile.NULL
		this.download_buf=string.NULL
		//we need to actually send the CTRL+C
		this.send("\x03")
	}
	JS_destroy=function(JSContext JS){
		this.destroy()
		return 0;
	}
	JS_write=function(JSContext JS){
		auto s=JS.Param(0).as(string)
		if s:
			this.write(s)
		return 0;
	}
	JS_send=function(JSContext JS){
		auto s=JS.Param(0).as(string)
		if s:
			this.send(s)
		return 0;
	}
	JS_getBgcolor=function(JSContext JS){
		auto colors=this.colors
		auto bg=this.curAttr & 0x1ff;
		return JS.Return(colors[bg])
	}
	__JS_prototype=function(JSObject proto){
		proto.ExportProperty(this,"cols")
		proto.ExportProperty(this,"rows")
		proto.ExportProperty(this,"n_valid_lines")
		proto.ExportProperty(this,"progress_value")
		proto.ExportProperty(this,"got_enter_from_input")
		proto.ExportMethod(this,"destroy",JS_destroy)
		proto.ExportMethod(this,"write",JS_write)
		proto.ExportMethod(this,"send",JS_send)
		proto.ExportMethod(this,"getBgcolor",JS_getBgcolor)
	}
	
	/////////////
	x_rendered=0.f
	y_rendered=0.f
	selecting=0
	sel_x0=0
	sel_y0=0
	sel_x1=0
	sel_y1=0
	got_enter_from_input=0
	proc=System.Processes.CProcess.NULL
	auto __done__()
		this.destroy();
	//w_rendered=0.f
	//h_rendered=0.f
};
//__enable_dynamic_members(Terminal);

/**
* Colors
*/

swaprb=inline(a){
	return ((a&0xff)<<16)+(a&0xff00)+((a&0xff0000)>>16)+0xff000000;
};

// Colors 0-15
g_tangoColors=[
	// dark:
	swaprb(0x2e3436),
	swaprb(0xcc0000),
	swaprb(0x4e9a06),
	swaprb(0xc4a000),
	swaprb(0x3465a4),
	swaprb(0x75507b),
	swaprb(0x06989a),
	swaprb(0xd3d7cf),
	// bright:
	swaprb(0x555753),
	swaprb(0xef2929),
	swaprb(0x8ae234),
	swaprb(0xfce94f),
	swaprb(0x729fcf),
	swaprb(0xad7fa8),
	swaprb(0x34e2e2),
	swaprb(0xeeeeec),
];

// Colors 0-15 + 16-255
// Much thanks to TooTallNate for writing this.
g_colors=(function() {
	auto colors=g_tangoColors, r=[0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff], i;

	// 16-231
	i=0;
	for (; i < 216; i++) {
		out(r[(i / 36) % 6 | 0], r[(i / 6) % 6 | 0], r[i % 6]);
	}

	// 232-255 (grey)
	i=0;
	for (; i < 24; i++) {
		auto rx=8 + i * 10;
		out(rx, rx, rx);
	}

	inline out(r, g, b) {
		colors.push(r+g*256+b*65536+0xff000000);
	}
	/////////////////
	colors.push(colors[0])
	colors.push(colors[7])

	return colors;
})();

//g_vcolors=(function() {
//  auto out=[], colors=g_colors, i=0, color;
//  for (; i < 256; i++) {
//    color=parseInt(colors[i].substring(1), 16);
//    out.push([
//      (color >> 16) & 0xff,
//      (color >> 8) & 0xff,
//      color & 0xff
//    ]);
//  }
//  return out;
//})();

/**
* Options
*/

//g_focus=null;

Gui2D.registerUIExtension(function(JSObject JS_UI,Gui2D.CUISandbox sbox,int is_real){
	JS_UI["InitTerminal"]=function(JSContext JS){
		js_term=JS.Param(0).as(JSObject)
		cols=JS.Param(1).as(int)
		rows=JS.Param(2).as(int)
		auto shell_args=JS.Param(3).as(JSObject)
		auto spath=JS.Param(4).or(".")
		auto finalization_callback=JS.Param(5).as(JSObject)
		if shell_args:
			auto n=shell_args.length()
			auto args=[shell_args[i].as(string) for i=0:n-1]
			foreach s,I in args
				if !s:
					return JS.ReturnError("bad args")
			proc=System.Processes.RunPiped(args,spath,0,"new_job,input,output,error")
			if !proc:
				//job object creation may fail
				proc=System.Processes.RunPiped(args,spath,0,"input,output,error")
		else
			proc=typeof(proc).NULL
		term=new Terminal(cols,rows)
		term.JS=JS
		term.input_pipe_queue=new string
		term.proc=proc
		if proc&&proc.pipe_2nd:
			PipeWaiter.SetPipeDataCallback(proc.pipe_2nd,function(string s){
				if term.download_buf:
					term.downloadWrite(s)
				else
					term.write(s)
				JS_UI.CallMethod(int,"Refresh")
			},function(){
				if finalization_callback:
					finalization_callback.Call(int)
			})
		//term.OnData=function(string s0){
		//	if !proc||!proc.pipe:return
		//	term.input_pipe_queue.push(s0)
		//	nwritten=proc.pipe.Write(term.input_pipe_queue)
		//	if nwritten>0&&nwritten<term.input_pipe_queue.n:
		//		copy(term.input_pipe_queue[0:],term.input_pipe_queue[nwritten:])
		//	term.input_pipe_queue.n-=nwritten
		//}
		js_term["m_term"]=term
		js_term["OnFocus"]=function(JSContext JS){
			if term.sendFocus: term.send('\x1b[I');
			term.has_focus=1
			return 0
		}
		js_term["OnBlur"]=function(JSContext JS){
			if term.sendFocus: term.send('\x1b[O');
			term.has_focus=0
			return 0
		}
		js_term["Download"]=function(JSContext JS){
			fn_local=JS.Param(0).as(string)
			fn_remote=JS.Param(1).as(string)
			term.download(fn_local,fn_remote)
			return 0
		}
		js_term["Render"]=function(JSContext JS){
			////////////////////
			g_renderer=Gui2D.detail.g_renderer
			term.need_update=0
			x=JS.Param(0).as(float)
			y=JS.Param(1).as(float)
			w=JS.Param(2).as(float)
			h=JS.Param(3).as(float)
			term.x_rendered=x
			term.y_rendered=y
			x*=g_renderer.m_pixels_per_unit
			y*=g_renderer.m_pixels_per_unit
			w*=g_renderer.m_pixels_per_unit
			h*=g_renderer.m_pixels_per_unit
			//////////////
			//clear it
			colors=term.colors
			bg=term.curAttr & 0x1ff;
			//DrawRectangle=inline(x,y,w,h,C)
			//	g_renderer.DrawRectangle(x*g_renderer.m_pixels_per_unit,y*g_renderer.m_pixels_per_unit,w*g_renderer.m_pixels_per_unit,h*g_renderer.m_pixels_per_unit,C)
			g_renderer.DrawRectangle(x,y,w,h,colors[bg])
			//////////////
			//get the font
			embolden=JS.GetThis()["embolden"].or(200)
			fnt_scaled=JS.GetThis()["font"].as(Gui2D.detail.TFont)
			fnt_scaled.h*=g_renderer.m_pixels_per_unit
			fnt_bold_scaled=fnt_scaled
			fnt_bold_scaled.embolden+=embolden
			if g_renderer.m_srgb_supported:
				fnt_scaled.SmartEmbolden(term.colors[256])
				fnt_bold_scaled.SmartEmbolden(term.colors[256])
			//////////////
			//resize the terminal? not yet
			w_char=g_renderer.GetCharacterAdvance(fnt_scaled,int(' '))
			h_char=g_renderer.GetCharacterHeight(fnt_scaled)
			//cols=max(int(floor(w/w_char)),2)
			//rows=min(max(int(floor(h/h_char)),1),term.scrollback)
			//term.resize(cols,rows)
			//////////////
			//the bell shake
			tick_now=System.Time.tick64()
			if (term.bell_tick-tick_now)>0LL:
				//we're in the bell, shake the whole screen
				x+=w_char*0.25f*(Random(f32)-0.5f)
				JS_UI.CallMethod(int,"AutoRefresh")
			//////////////
			//render the content
			lines=term.lines
			ybaseline=g_renderer.GetFontBaseline(fnt_scaled)
			y_underline=ybaseline*1.05f
			h_underline=ybaseline*0.2f
			sel_x0=term.sel_x0
			sel_y0=term.sel_y0
			sel_x1=term.sel_x1
			sel_y1=term.sel_y1
			ytop=(term.n_valid_lines<term.scrollback?0:(term.ybase+term.rows)%term.scrollback)
			sel_y0=(sel_y0+term.scrollback-ytop)%term.scrollback
			sel_y1=(sel_y1+term.scrollback-ytop)%term.scrollback
			if sel_y0>sel_y1||sel_y0==sel_y1&&sel_x0>sel_x1:
				tmp=sel_x0;sel_x0=sel_x1;sel_x1=tmp
				tmp=sel_y0;sel_y0=sel_y1;sel_y1=tmp
			for j=0:term.rows-1
				row=(term.ydisp+j)%term.scrollback
				row_base=row*(3*term.cols)
				if row==term.n_valid_lines:
					break
				sel_x0_j=term.cols
				sel_x1_j=0
				if term.selecting:
					row_topbased=(row+term.scrollback-ytop)%term.scrollback
					if row_topbased==sel_y0:
						sel_x0_j=sel_x0
					else if row_topbased>sel_y0:
						sel_x0_j=0
					if row_topbased==sel_y1:
						sel_x1_j=sel_x1
					else if row_topbased<sel_y1:
						sel_x1_j=term.cols
				for i=0:term.cols-1
					data=lines[row_base+i*3+0]
					ch=lines[row_base+i*3+1]
					ch_width=lines[row_base+i*3+2]
					if !ch_width:continue
					bg=data & 0x1ff;
					fg=(data >> 9) & 0x1ff;
					flags=data >> 18;
					if i>=sel_x0_j&&i<sel_x1_j:
						flags^=g_flags.INVERSE
					
					if (flags & g_flags.BLINK) {
						//QM: blink would be CPU-consuming in GL
						flags |= g_flags.BOLD;
					}
	
					if (flags & g_flags.BOLD) {
						// See: XTerm*boldColors
						if (fg < 8) fg += 8;
					}
	
					// If inverse flag is on, then swap the foreground and background variables.
					if (flags & g_flags.INVERSE) {
						/* One-line variable swap in JavaScript: http://stackoverflow.com/a/16201730 */
						tmp=bg;bg=fg;fg=tmp;
						// Should inverse just be before the
						// above boldColors effect instead?
						if ((flags & 1) && fg < 8) 
							fg += 8;
					}
	
					//if (flags & g_flags.INVISIBLE) {
					//  classNames.push('xterm-hidden');
					//}
	
					/**
					* Weird situation: Invert flag used black foreground and white background results
					* in invalid background color, positioned at the 256 index of the 256 terminal
					* color map. Pin the colors manually in such a case.
					*
					* Source: https://github.com/sourcelair/xterm.js/issues/57
					*/
					if (flags & g_flags.INVERSE) {
						if (bg == 257) {
							bg=15;
						}
						if (fg == 256) {
							fg=0;
						}
					}
					x_ch=x+float(i)*w_char
					y_ch=y+float(j)*h_char
					g_renderer.DrawRectangle(x_ch,y_ch,w_char*float(ch_width),h_char,colors[bg])
					if !(flags & g_flags.INVISIBLE):
						if ch!=32&&ch!=9&&ch!=0:
							if (flags & g_flags.BOLD) {
								g_renderer.DrawChar(fnt_bold_scaled,x_ch,y_ch,colors[fg],ch)
							}else{
								g_renderer.DrawChar(fnt_scaled,x_ch,y_ch,colors[fg],ch)
							}
						if (flags & g_flags.UNDERLINE) {
							g_renderer.DrawRectangle(x_ch,y_ch+y_underline,w_char*float(ch_width),h_underline, colors[fg])
						}
			////////////////////
			//render the IME composing text
			y_cur_term=term.y+(term.ybase-term.ydisp+term.scrollback)%term.scrollback
			if y_cur_term<term.rows&&y_cur_term>=0:
				x_cur=x+float(term.x)*w_char
				y_cur=y+float(y_cur_term)*h_char
				if term.m_IME_overlay:
					//bg=term.curAttr & 0x1ff;
					fg=(term.curAttr >> 9) & 0x1ff;
					s=term.m_IME_overlay
					adv_tot=0.f
					for ch in Gui2D.Utf8Chars(s)
						dx=g_renderer.GetCharacterAdvance(fnt_scaled,ch)
						g_renderer.DrawChar(fnt_scaled,x_cur+adv_tot,y_cur,colors[fg]&0x7fffffff,ch)
						adv_tot+=dx
					x_cur+=adv_tot
				////////////////////
				//render the cursor
				if !term.cursorHidden&&term.has_focus:
					wnd_obj=JS_UI["context_window"].as(JSObject)
					fg=(term.curAttr >> 9) & 0x1ff;
					JS_UI.CallMethod(int,"SetCaret",wnd_obj,
						x_cur,y_cur+y_underline-h_char*0.1,
						w_char,h_char*0.2,colors[fg],500)
			return 0
		}
		js_term["OnKeyDown"]=function(JSContext JS){
			ev=JS.Param(0).as(JSObject)
			if term.keyDown(JS,ev):
				term.need_update=1
				JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["OnTextEdit"]=function(JSContext JS){
			ev=JS.Param(0).as(JSObject)
			text=ev["text"].as(string)
			if text&&text.n:
				term.m_IME_overlay=text
			else
				term.m_IME_overlay=string.NULL
			JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["OnTextInput"]=function(JSContext JS){
			ev=JS.Param(0).as(JSObject)
			text=ev["text"].as(string)
			term.m_IME_overlay=string.NULL
			if text&&text.n:
				term.onTextInput(text)
			return 0
		}
		js_term["NeedUpdate"]=function(JSContext JS){
			return JS.Return(term.need_update)
		}
		js_term["GetTitle"]=function(JSContext JS){
			if term.title:
				return JS.Return(term.title)
			else
				return 0
		}
		js_term["OnMouseWheel"]=function(JSContext JS){
			ev=JS.Param(0).as(JSObject)
			dy=ev["y"].as(int)
			term.scrollDisp(-3*dy)
			term.need_update=1
			JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["GetScrollValue"]=function(JSContext JS){
			scroll_tot=term.n_valid_lines-term.rows
			scroll_cur=term.ydisp
			if scroll_cur>term.ybase:
				scroll_cur-=term.scrollback
			scroll_cur-=(term.ybase-scroll_tot)
			if !(scroll_tot>0):
				return 0
			else
				return JS.Return(double(scroll_cur)/double(scroll_tot))
		}
		js_term["SetScrollValue"]=function(JSContext JS){
			value=JS.Param(0).as(double)
			scroll_tot=term.n_valid_lines-term.rows
			if scroll_tot>0:
				scroll_cur=min(max(int(value*double(scroll_tot)),0),scroll_tot)
				term.ydisp=term.ybase-scroll_tot+scroll_cur+term.scrollback
				term.userScrolling=(term.ydisp!=term.ybase)
				term.need_update=1
				JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		MouseToTermPos=inline(JSContext JS){
			js_this=JS.GetThis()
			JS_UI.CallMethod(int,"SetFocus",js_this)
			ev=JS.Param(0).as(JSObject)
			x=ev["x"].as(float)
			y=ev["y"].as(float)
			x-=term.x_rendered
			y-=term.y_rendered
			fnt=JS.GetThis()["font"].as(Gui2D.detail.TFont)
			w_char=Gui2D.detail.g_renderer.GetCharacterAdvance(fnt,int(' '))
			h_char=Gui2D.detail.g_renderer.GetCharacterHeight(fnt)
			ytop=(term.n_valid_lines<term.scrollback?0:(term.ybase+term.rows)%term.scrollback)
			available_lines_neg=(term.ydisp-ytop+term.scrollback)%term.scrollback
			available_lines=(term.ybase-term.ydisp)
			if available_lines<0:
				available_lines+=term.scrollback
			xi=min(max(int(floor(x/w_char)),0),term.cols)
			yi=min(max(min(max(int(floor(y/h_char)),-term.rows),term.rows*2),-available_lines_neg),available_lines+term.rows-1)
			yi_global=(yi+term.ydisp)%term.scrollback
			if yi_global<0:
				yi_global+=term.scrollback
			yi_global=min(max(yi_global,0),term.n_valid_lines-1)
			if yi<0:
				term.scrollDisp(yi)
			else if yi>=term.rows:
				term.scrollDisp(yi-(term.rows-1))
			return (xi,yi_global)
		}
		js_term["OnMouseDown"]=function(JSContext JS){
			ev=JS.Param(0).as(JSObject)
			button=ev["button"].as(int)
			clicks=ev["clicks"].as(int)
			(xi,yi_global)=MouseToTermPos(JS)
			if button==1:
				//left click - selection
				if clicks>=4:
					//quadraple click for select-all
					auto ytop=(term.n_valid_lines<term.scrollback?0:(term.ybase+term.rows)%term.scrollback)
					term.selecting=2
					term.sel_x0=0
					term.sel_y0=ytop
					term.sel_x1=term.cols
					term.sel_y1=(term.ybase+term.rows-1)%term.scrollback
				else if clicks>=2:
					//select paragraph first
					auto ytop=(term.n_valid_lines<term.scrollback?0:(term.ybase+term.rows)%term.scrollback)
					term.selecting=2
					term.sel_x0=0
					term.sel_y0=yi_global
					term.sel_x1=term.cols
					term.sel_y1=yi_global
					while term.sel_y0!=ytop:
						auto y0next=term.sel_y0-1
						if y0next<0:
							y0next+=term.scrollback
						if uptr(y0next)>=uptr(term.line_end_states.n)||term.line_end_states[y0next]==0:
							break
						term.sel_y0=y0next
					for(;;)
						if uptr(term.sel_y1)>=uptr(term.line_end_states.n)||term.line_end_states[term.sel_y1]==0:
							break
						auto y1next=term.sel_y1+1
						if y1next>=term.scrollback:
							y1next-=term.scrollback
						if y1next==ytop:break
						term.sel_y1=y1next
					term.s_parse_buffer.n=0
					for j=term.sel_y0:term.sel_y1
						row=(ytop+j)%term.scrollback
						for i=0:term.cols-1
							auto addr=(row*term.cols+i)*3
							if uptr(addr+2)<uptr(term.lines.n)&&term.lines[addr+2]:
								term.s_parse_buffer.PushUnicode(term.lines[addr+1])
					if term.s_parse_buffer.n:
						term.s_parse_buffer.push('\n')
						js_this=JS.GetThis()
						if JS["UI"].CallMethod(int,"ParseTerminalOutput",js_this,term.s_parse_buffer,1):
							clicks=3
					//re-select word if ParseTerminalOutput failed
					if clicks==2:
						term.selecting=2
						term.sel_x0=xi
						term.sel_y0=yi_global
						term.sel_x1=xi
						term.sel_y1=yi_global
						pchar_line=yi_global*term.cols
						while term.sel_x0>0:
							addr=(pchar_line+term.sel_x0-1)*3
							if uptr(addr)>=uptr(term.lines.n)||term.lines[addr+2]&&(term.lines[addr+1]==' '||term.lines[addr+1]=='\t'):
								break
							term.sel_x0--
						if term.sel_x1<term.cols:
							for(;;)
								term.sel_x1++
								if term.sel_x1>=term.cols:break
								addr=(pchar_line+term.sel_x1)*3
								if uptr(addr)>=uptr(term.lines.n)||term.lines[addr+2]&&(term.lines[addr+1]==' '||term.lines[addr+1]=='\t'):
									break
				else
					//drag
					term.selecting=1
					term.sel_x0=xi
					term.sel_y0=yi_global
					term.sel_x1=xi
					term.sel_y1=yi_global
					js_this=JS.GetThis()
					JS_UI.CallMethod(int,"CaptureMouse",js_this)
			else if button==3:
				//right click - paste or copy confirmation
				if term.selecting:
					term.confirmCopy(JS)
				else
					s=SDL.detail.SDL_GetClipboardText()
					if s:
						lg=System.OS_API.strlen(s)
						text=new string
						text.BindToPointer(s,lg)
						term.onTextInput(text)
						text.discard()
						SDL.detail.SDL_free(s)
			JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["OnMouseMove"]=function(JSContext JS){
			if term.selecting==1:
				(xi,yi_global)=MouseToTermPos(JS)
				term.sel_x1=xi
				term.sel_y1=yi_global
				JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["OnMouseUp"]=function(JSContext JS){
			if term.selecting==1:
				(xi,yi_global)=MouseToTermPos(JS)
				term.sel_x1=xi
				term.sel_y1=yi_global
				term.selecting=2
				if term.sel_x0==term.sel_x1&&term.sel_y0==term.sel_y1:
					term.selecting=0
				js_this=JS.GetThis()
				JS_UI.CallMethod(int,"ReleaseMouse",js_this)
				JS_UI.CallMethod(int,"Refresh")
			return 0
		}
		js_term["WriteTerminal"]=function(JSContext JS){
			s=JS.Param(0).as(string)
			if s:
				term.write(s)
			return 0
		}
		js_term["Terminate"]=function(JSContext JS){
			if proc:
				//send CTRL+C
				//term.send("\x03")
				proc.Terminate()
				//proc=System.Processes.CProcess.NULL
			return 0
		}
		js_term["toJSON"]=function(JSContext JS){
			return 0
		}
		js_term["GetExitCode"]=function(JSContext JS){
			if proc:
				ret=proc.exit_code()
				return JS.Return(ret)
			else
				return JS.Return(-1)
		}
		return JS.Return(!!proc)
	}
	JS_UI["ScaleFont"]=function(JSContext JS){
		fnt=JS.Param(0).as(Gui2D.detail.TFont)
		scale=JS.Param(1).as(float)
		fnt.h*=scale
		return JS.Return(fnt)
	}
})

/**
* Flags used to render terminal text properly
*/
g_flags={
	BOLD: 1,
	UNDERLINE: 2,
	BLINK: 4,
	INVERSE: 8,
	INVISIBLE: 16
};

KMOD_NONE = 0x0000
KMOD_LSHIFT = 0x0001
KMOD_RSHIFT = 0x0002
KMOD_LCTRL = 0x0040
KMOD_RCTRL = 0x0080
KMOD_LALT = 0x0100
KMOD_RALT = 0x0200
KMOD_LGUI = 0x0400
KMOD_RGUI = 0x0800
KMOD_NUM = 0x1000
KMOD_CAPS = 0x2000
KMOD_MODE = 0x4000
KMOD_RESERVED = 0x8000

KMOD_CTRL=(KMOD_LCTRL|KMOD_RCTRL)
KMOD_SHIFT=(KMOD_LSHIFT|KMOD_RSHIFT)
KMOD_ALT=(KMOD_LALT|KMOD_RALT)
KMOD_GUI=(KMOD_LGUI|KMOD_RGUI)
KMOD_WIN=KMOD_GUI

String_fromCharCode=inline(a){
	auto ret=new string
	ret.PushUnicode(a)
	return ret
}
SDLK_Fn=1073741881

/**
* Log the current state to the console.
*/
//Terminal_prototype.log=function() {
//	if (!this.debug) return;
//	if (!this.context.console || !this.context.console.log) return;
//	auto args=Array.prototype.slice.call(arguments);
//	this.context.console.log.apply(this.context.console, args);
//};

/**
* Log the current state as error to the console.
*/
//Terminal_prototype.error=function() {
//	if (!this.debug) return;
//	if (!this.context.console || !this.context.console.error) return;
//	auto args=Array.prototype.slice.call(arguments);
//	this.context.console.error.apply(this.context.console, args);
//};

/**
* Character Sets
*/

g_charsets={};

// DEC Special Character and Line Drawing Set.
// http://vt100.net/docs/vt102-ug/table5-13.html
// A lot of curses apps use this if they see TERM=xterm.
// testing: echo -e '\e(0a\e(B'
// The xterm output sometimes seems to conflict with the
// reference above. xterm seems in line with the reference
// when running vttest however.
// The table below now uses xterm's output from vttest.
g_charsets.SCLD=(inline(){ // (0
	auto ret=new int[int]
	ret[int('`')]=0x25c6; // ''
	ret[int('a')]=0x2592; // ''
	ret[int('b')]=0x0009; // '\t'
	ret[int('c')]=0x000c; // '\f'
	ret[int('d')]=0x000d; // '\r'
	ret[int('e')]=0x000a; // '\n'
	ret[int('f')]=0x00b0; // ''
	ret[int('g')]=0x00b1; // ''
	ret[int('h')]=0x2424; // '\u2424' (NL)
	ret[int('i')]=0x000b; // '\v'
	ret[int('j')]=0x2518; // ''
	ret[int('k')]=0x2510; // ''
	ret[int('l')]=0x250c; // ''
	ret[int('m')]=0x2514; // ''
	ret[int('n')]=0x253c; // ''
	ret[int('o')]=0x23ba; // ''
	ret[int('p')]=0x23bb; // ''
	ret[int('q')]=0x2500; // ''
	ret[int('r')]=0x23bc; // ''
	ret[int('s')]=0x23bd; // ''
	ret[int('t')]=0x251c; // ''
	ret[int('u')]=0x2524; // ''
	ret[int('v')]=0x2534; // ''
	ret[int('w')]=0x252c; // ''
	ret[int('x')]=0x2502; // ''
	ret[int('y')]=0x2264; // ''
	ret[int('z')]=0x2265; // ''
	ret[int('{')]=0x03c0; // ''
	ret[int('|')]=0x2260; // ''
	ret[int('}')]=0x00a3; // ''
	ret[int('~')]=0x00b7; // ''
	return ret;
})();

g_charsets.UK=int[int].NULL; // (A
g_charsets.US=int[int].NULL; // (B (USASCII)
g_charsets.Dutch=int[int].NULL; // (4
g_charsets.Finnish=int[int].NULL; // (C OR (5
g_charsets.French=int[int].NULL; // (R
g_charsets.FrenchCanadian=int[int].NULL; // (Q
g_charsets.German=int[int].NULL; // (K
g_charsets.Italian=int[int].NULL; // (Y
g_charsets.NorwegianDanish=int[int].NULL; // (E OR (6
g_charsets.Spanish=int[int].NULL; // (Z
g_charsets.Swedish=int[int].NULL; // (H OR (7
g_charsets.Swiss=int[int].NULL; // (=
g_charsets.ISOLatin=int[int].NULL; // /A

function matchColor(r1, g1, b1) {
	auto hash=(r1 << 16) | (g1 << 8) | b1;

	if (matchColor_cache[hash] >0) {
		return matchColor_cache[hash]-1;
	}

	auto ldiff=0x3fffffff, li=-1, i=0, c, r2, g2, b2, diff;

	for (; i < g_colors.n; i++) {
		c=g_colors[i];
		r2=((c>>0)&0xff);
		g2=((c>>8)&0xff);
		b2=((c>>16)&0xff);

		diff=matchColorDistance(r1, g1, b1, r2, g2, b2);

		if (diff == 0) {
			li=i;
			break;
		}

		if (diff < ldiff) {
			ldiff=diff;
			li=i;
		}
	}

	matchColor_cache[hash]=li+1;
	return li;
}

matchColor_cache=new int[int];

// http://stackoverflow.com/questions/1633828
matchColorDistance=function(r1, g1, b1, r2, g2, b2) {
	return (sqr(30 * (r1 - r2))
		+ sqr(59 * (g1 - g2))
		+ sqr(11 * (b1 - b2)));
};

// extracted from https://www.cl.cam.ac.uk/%7Emgk25/ucs/wcwidth.c
// combining characters
auto COMBINING=[
	[0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489],
	[0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2],
	[0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603],
	[0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670],
	[0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED],
	[0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A],
	[0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902],
	[0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D],
	[0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981],
	[0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD],
	[0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C],
	[0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D],
	[0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC],
	[0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD],
	[0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C],
	[0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D],
	[0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0],
	[0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48],
	[0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC],
	[0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD],
	[0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D],
	[0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6],
	[0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E],
	[0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC],
	[0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35],
	[0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E],
	[0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97],
	[0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030],
	[0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039],
	[0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F],
	[0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753],
	[0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD],
	[0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD],
	[0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922],
	[0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B],
	[0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34],
	[0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42],
	[0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF],
	[0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063],
	[0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F],
	[0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B],
	[0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F],
	[0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB],
	[0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F],
	[0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169],
	[0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD],
	[0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F],
	[0xE0100, 0xE01EF]
];
// binary search
function bisearch(ucs) {
	auto min=0;
	auto max=COMBINING.n - 1;
	auto mid;
	if (ucs < COMBINING[0][0] || ucs > COMBINING[max][1])
		return false;
	while (max >= min) {
		mid=(min + max)>>1;
		if (ucs > COMBINING[mid][1])
			min=mid + 1;
		else if (ucs < COMBINING[mid][0])
			max=mid - 1;
		else
			return true;
	}
	return false;
}
function wcwidth(ucs) {
	// test for 8-bit control characters
	if (ucs == 0)
		return 0;
	if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
		return 0;
	// binary search in table of non-spacing characters
	if (bisearch(ucs))
		return 0;
	// if we arrive here, ucs is not a combining or C0/C1 control character
	return 1 +
		(
		ucs >= 0x1100 &&
		(
			ucs <= 0x115f ||                // Hangul Jamo init. consonants
			ucs == 0x2329 ||
			ucs == 0x232a ||
			(ucs >= 0x2e80 && ucs <= 0xa4cf && ucs != 0x303f) ||  // CJK..Yi
			(ucs >= 0xac00 && ucs <= 0xd7a3) ||    // Hangul Syllables
			(ucs >= 0xf900 && ucs <= 0xfaff) ||    // CJK Compat Ideographs
			(ucs >= 0xfe10 && ucs <= 0xfe19) ||    // Vertical forms
			(ucs >= 0xfe30 && ucs <= 0xfe6f) ||    // CJK Compat Forms
			(ucs >= 0xff00 && ucs <= 0xff60) ||    // Fullwidth Forms
			(ucs >= 0xffe0 && ucs <= 0xffe6) ||
			(ucs >= 0x20000 && ucs <= 0x2fffd) ||
			(ucs >= 0x30000 && ucs <= 0x3fffd)
		)
	);
};

}
